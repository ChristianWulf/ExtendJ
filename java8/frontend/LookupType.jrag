aspect LookupType {

	/*
	These refines are important for the lambda expressions, because the this
	and super keywords for lambdas refer to the same thing that they do in outer 
	context, which means the anonymous classes declared by the lambda should NOT
	be the result type for a this or super access. These refines makes sure to
	bypass all hostTypes which are an anonymous lambda class until another hostType
	is found.  
	*/
	refine GenericsTypeAnalysis
	eq ThisAccess.decl() {
		TypeDecl typeDecl;
		if(isQualified())
			typeDecl = qualifier().type();
		else {
			typeDecl = hostType();
			while(typeDecl instanceof LambdaAnonymousDecl)
				typeDecl = typeDecl.enclosingType();
		}
		
		if(typeDecl instanceof ParTypeDecl)
			typeDecl = ((ParTypeDecl)typeDecl).genericDecl();
		return typeDecl;
	}
	
	refine GenericsTypeAnalysis
	eq SuperAccess.decl() {
		TypeDecl typeDecl;
		if(isQualified())
			typeDecl = qualifier().type();
		else {
			typeDecl = hostType();
			while(typeDecl instanceof LambdaAnonymousDecl)
				typeDecl = typeDecl.enclosingType();
		}
		
		if(typeDecl instanceof ParTypeDecl)
			typeDecl = ((ParTypeDecl)typeDecl).genericDecl();
		return typeDecl;
	}
	
	refine TypeAnalysis
	eq SuperAccess.type() {
		TypeDecl typeDecl = decl();
		if(typeDecl.isInterfaceDecl()) {
			if(isQualified() && qualifier().type() == typeDecl)
				return typeDecl;
		}
		if(!typeDecl.isClassDecl())
			return unknownType();
		ClassDecl classDecl = (ClassDecl)typeDecl;
		if(!classDecl.hasSuperclass())
			return unknownType();
		return classDecl.superclass();
	}
}

aspect SpecialClasses {
	/*syn lazy TypeDecl Program.typeFunctionalInterface() {
		List<Modifier> list = new List<Modifier>();
		list.add(new Modifier("public"));
		return new AnnotationDecl(new Modifiers(list), "FunctionalInterface", new List<BodyDecl>());
	}
  
	eq Program.getChild().typeFunctionalInterface() = typeFunctionalInterface();
	inh TypeDecl Expr.typeFunctionalInterface();*/
}

aspect LookupFullyQualifiedTypes {
	/*refine LookupFullyQualifiedTypes
	eq Program.lookupLibType(String packageName, String typeName) {
		String fullName = packageName.equals("") ? typeName : packageName + "." + typeName;
		
		if(typeName.equals("FunctionalInterface"))
			return typeFunctionalInterface();
		
		// Check the primitive types
		if (packageName.equals(PRIMITIVE_PACKAGE_NAME)) {
			PrimitiveCompilationUnit unit = getPrimitiveCompilationUnit();
			if (typeName.equals("boolean")) return unit.typeBoolean();
			if (typeName.equals("byte")) return unit.typeByte();
			if (typeName.equals("short")) return unit.typeShort();
			if (typeName.equals("char")) return unit.typeChar();
			if (typeName.equals("int")) return unit.typeInt();
			if (typeName.equals("long")) return unit.typeLong();
			if (typeName.equals("float")) return unit.typeFloat();
			if (typeName.equals("double")) return unit.typeDouble();
			if (typeName.equals("null")) return unit.typeNull();
			if (typeName.equals("void")) return unit.typeVoid();
			if (typeName.equals("Unknown")) return unit.unknownType(); // Is this needed?
		}
		// Check the library:
		//  A type may not be in the library but an NTA cannot map to null.
		//  We need to do some double work to step around this.
		//  We check the classpath directly (the same thing the library NTA does)
		//  to prevent that we call the nta for a name that gives null back
		//else if (getCompilationUnit(fullName) != null) {

		// Found a library unit, check it for type
		CompilationUnit libUnit = getLibCompilationUnit(fullName);
		if (libUnit != null) {
			for(int j = 0; j < libUnit.getNumTypeDecl(); j++) {
				TypeDecl type = libUnit.getTypeDecl(j);
				if(type.fullName().equals(fullName)) {
					return type;
				}
			}
		}
		// No type found in the library
		return null;
	}*/
}