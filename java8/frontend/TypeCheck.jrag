aspect TypeCheck {
	inh TypeDecl LambdaParameters.unknownType();
	inh TypeDecl InferredParameterDeclaration.unknownType();
	inh TypeDecl LambdaBody.unknownType();
	eq LambdaExpr.getLambdaParameters().unknownType() = unknownType();
	eq LambdaExpr.getLambdaBody().unknownType() = unknownType();

	//syn lazy TypeDecl LambdaExpr.type() = unknownType();
	//syn lazy TypeDecl MethodReference.type() = unknownType();
	syn lazy TypeDecl ConstructorReference.type() = unknownType();
	syn lazy TypeDecl IntersectionCastExpr.type() = unknownType();
	
	
	
	// Lambdas should propagate target return type to returns in lambda body
	eq BlockLambdaBody.getBlock().returnType() {
		TypeDecl decl = enclosingLambda().targetType();
		if(decl == null)
			return unknownType();
		else if(!(decl instanceof InterfaceDecl))
			return unknownType();
		else {
			InterfaceDecl iDecl = (InterfaceDecl)decl;
			if(!iDecl.isFunctional())
				return unknownType();
			else {
				return iDecl.functionDescriptor().method.type();
			}
		}
	}
	
	
	// Does not handle invocation context
	syn lazy TypeDecl LambdaExpr.type() {
		// 15.27.3
		if(!assignmentContext() && !castContext()) 
			return unknownType();
		if(targetInterface() == null)
			return unknownType();
		
		InterfaceDecl iDecl = targetInterface();
		if(!iDecl.hasFunctionDescriptor()) {
			return unknownType();
		}
		
		return iDecl;
	}
	
	// Does not handle invocation context
	syn lazy TypeDecl MethodReference.type() {
		// 15.28.1
		if(!assignmentContext() && !castContext()) 
			return unknownType();
		if(targetInterface() == null)
			return unknownType();
			
		InterfaceDecl iDecl = targetInterface();
		if(!iDecl.hasFunctionDescriptor()) {
			return unknownType();
		}
		
		return iDecl;
	}
	
	
	/* TODO: Type check that works for wildcard-parameterized interfaces */
	public void LambdaExpr.typeCheck() {
		if(!assignmentContext() && !castContext() && !invocationContext()) {
			// 15.27
			error("Lambda expressions must target a functional interface");
			return;
		}
		
		/* ONLY TEMPORARY BECAUSE TYPE CHECK FOR INVOCATIONS
			NOT YET IMPLEMENTED */
		if(!assignmentContext() && ! castContext())
			return;

		if(targetType() == null) {
			// 15.27
			error("Lambda expressions must target a functional interface");
			return;
		}	
		else if(!(targetType() instanceof InterfaceDecl)) {
			// 15.27
			error("Lambda expressions must target a functional interface");
			return;
		}
		InterfaceDecl iDecl = (InterfaceDecl)targetType();
		if(!iDecl.hasFunctionDescriptor()) {
			error("Lambda expressions must target a functional interface");
			return;
		}
		if(!iDecl.isFunctional()) {
			// 15.27
			error("Interface " + iDecl.name() + " is not functional and can therefore not be targeted by a lambda expression");
			return;
		}
		
		if(iDecl.functionDescriptor().isGeneric()) {
			// 15.27
			error("Illegal lambda expression: Method " + iDecl.functionDescriptor().method.name() + 
				" in functional interface " + iDecl.name() + " is generic");
			return;
		}
		
		if(!congruentTo(iDecl.functionDescriptor())) {
			// 15.27.3
			error("Lambda expression incompatible with method " + iDecl.functionDescriptor().method.name()
					+ " in functional interface " + iDecl.name());
		}		
	}
	
	
	public void BlockLambdaBody.typeCheck() {
		// 15.27.2
		if(!voidCompatible() && !valueCompatible()) {
			error("Block lambda bodies must be either void or value compatible");
		}
	}
	
	refine TypeCheck
	public void ReturnStmt.typeCheck() {
		if(enclosingLambda() == null || enclosingLambda().hostType() != hostType()) {
			if(hasResult() && !returnType().isVoid()) {
				if(!getResult().type().assignConversionTo(returnType(), getResult()))
					error("return value must be an instance of " + returnType().typeName() + " which " + getResult().type().typeName() + " is not");
			}
			// 8.4.5 8.8.5
			if(returnType().isVoid() && hasResult())
				error("return stmt may not have an expression in void methods");
			// 8.4.5
			if(!returnType().isVoid() && !hasResult())
				error("return stmt must have an expression in non void methods");
			if(enclosingBodyDecl() instanceof InstanceInitializer || enclosingBodyDecl() instanceof StaticInitializer)
				error("Initializers may not return");
		}
		else {
			if(hasResult() && !returnType().isVoid() && !(getResult() instanceof LambdaExpr)) {
				if(!getResult().type().assignConversionTo(returnType(), getResult()))
					error("return value must be an instance of " + returnType().typeName() + " which " + getResult().type().typeName() + " is not");
			}
		}
	}
	
	public void MethodReference.typeCheck() {
		// 15.28.1
		if(!assignmentContext() && !castContext() && !invocationContext()) {
			error("Method references must target a functional interface");
			return;
		}
		
		/* ONLY TEMPORARY BECAUSE TYPE CHECK FOR INVOCATIONS
			NOT YET IMPLEMENTED */
		if(!assignmentContext() && ! castContext())
			return;

		if(targetType() == null) {
			error("Method references must target a functional interface");
			return;
		}	
		else if(!(targetType() instanceof InterfaceDecl)) {
			error("Method references must target a functional interface");
			return;
		}
		InterfaceDecl iDecl = (InterfaceDecl)targetType();
		if(!iDecl.hasFunctionDescriptor()) {
			error("Method references must target a functional interface");
			return;
		}
		if(!iDecl.isFunctional()) {
			error("Interface " + iDecl.name() + " is not functional and can therefore not be targeted by a method reference");
			return;
		}
		
		MethodDecl found = null;
		// Lookup method here and check that one most specific can be found	
		if(this instanceof ExprMethodReference) {
			ExprMethodReference ref = (ExprMethodReference)this;
			found = ref.targetMethod();
			if(found.unknownMethod() == found) {
				// 15.28.1
				error("No method " + name() + " that is compatible with the method " + iDecl.functionDescriptor().method.fullSignature() + 
				 " in the functional interface " + iDecl.typeName() + " was found");
			}
			else if(found.isStatic()) {
				error("The method " + found.fullSignature() + " in type " + found.hostType().typeName() + 
						" must be accessed in a static way");
			}
		}
		else if(this instanceof TypeMethodReference) {
			TypeMethodReference ref = (TypeMethodReference)this;
			MethodDecl staticMethod = ref.targetStaticMethod();
			MethodDecl instanceMethod = ref.targetInstanceMethod();
			if(staticMethod.unknownMethod() != staticMethod && instanceMethod.unknownMethod() != instanceMethod) {
				error("Ambiguity error: two possible methods " + staticMethod.name() + " was found");
				return;
			}
			else if(staticMethod.unknownMethod() == staticMethod && instanceMethod.unknownMethod() == instanceMethod) {
				error("No method " + name() + " that is compatible with the method " + iDecl.functionDescriptor().method.fullSignature() + 
				 " in the functional interface " + iDecl.typeName() + " was found");
				 return;
			}
			else if(staticMethod.unknownMethod() != staticMethod && !staticMethod.isStatic()) {
				error("Cannot make a static reference to the non-static method " + staticMethod.fullSignature() + " in type " 
				 	 	+ staticMethod.hostType().typeName());
				return;
			}
			else if(instanceMethod.isStatic()) {
				error("The method " + instanceMethod.fullSignature() + " in type " + instanceMethod.hostType().typeName() + 
						" must be accessed in a static way");
				return;
			}
			else if(staticMethod.unknownMethod() != staticMethod) {
				found = staticMethod;
			}
			else {
				found = instanceMethod;
			}
		}
		
		if(found != null && found.unknownMethod() != found) {
			// Check that found is compatible with the function descriptor
			if(!iDecl.functionDescriptor().method.type().isVoid()) {
				// 15.28.1
				if(found.type().isVoid() || !found.type().assignConversionTo(iDecl.functionDescriptor().method.type(), null))
					error("Return type of referenced method " + found.fullSignature() + " is not compatible with method " + 
							iDecl.functionDescriptor().method.fullSignature() + " in functional interface " + iDecl.typeName());
			}
			
			for(int i = 0; i < found.getNumException(); i++) {
				TypeDecl exception = found.getException(i).type();
				/* This is supposed to be unchecked exception, but the attribute name
				   is currently inverted! */
				if(exception.isCheckedException())
					continue;
				
				boolean legalException = false;
				for(TypeDecl descriptorThrows : iDecl.functionDescriptor().throwsList) {
					if(exception.strictSubtype(descriptorThrows)) {
						legalException = true;
						break;
					}
				}
				if(!legalException) {
					// 15.28.1
					error("Referenced method " + found.name() + " throws unhandled exception type " + exception.typeName()); 
				}
			}
		}
	}
	
	refine TypeCheck 
	eq MethodDecl.mayOverride(MethodDecl m) {
		// 9.4.3
		if(isDefault() && m.hostType() == type().typeObject() && !m.isPrivate()) 
			return false;
		else
			return returnTypeSubstitutableFor(m);
	}
}

aspect LambdaParametersInference {
	inh lazy TypeDecl InferredParameterDeclaration.inferredType();
	eq InferredLambdaParameters.getParameters(int i).inferredType() {
		if(!(enclosingLambda().type() instanceof InterfaceDecl)) {
			return unknownType();
		}
		InterfaceDecl iDecl = (InterfaceDecl)enclosingLambda().type();
		if(!iDecl.hasFunctionDescriptor())
			return unknownType();
		else if(iDecl.functionDescriptor().method.getNumParameter() < i + 1)
			return unknownType();
		else
			return iDecl.functionDescriptor().method.getParameter(i).type();
	}
}