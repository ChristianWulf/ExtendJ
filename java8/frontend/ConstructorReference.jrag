aspect ConstructorReference {
	syn lazy ConstructorDecl ClassReference.targetConstructor(FunctionDescriptor f) {
		return syntheticInstanceExpr(f).decl();
	}
	
	syn nta lazy ClassInstanceExpr ClassReference.syntheticInstanceExpr(FunctionDescriptor f) {
		List<Expr> arguments = new List<Expr>();
		for(int i = 0; i < f.method.getNumParameter(); i++) {
			TypeDecl argumentType = f.method.getParameter(i).type();
			arguments.add(new SyntheticTypeAccess(argumentType));
		}
		
		ClassInstanceExpr instanceExpr = null;
		if(hasTypeArgument()) {
			instanceExpr = new ParConstructorReferenceAccess((Access)getTypeAccess().fullCopy(), arguments,
		 											new Opt(), (List<Access>)getTypeArgumentList().fullCopy(), f);
		}
		else {
			// Must check for raw reference type, and in that case infer using diamond (JLS 15.28.1)
			if(getTypeAccess().type().isRawType()) {
				DiamondAccess diamond = new DiamondAccess((Access)getTypeAccess().fullCopy());
				instanceExpr = new ConstructorReferenceAccess(diamond, arguments, f);
			}
			else {
				instanceExpr = new ConstructorReferenceAccess((Access)getTypeAccess().fullCopy(), arguments, f);
			}
		}
		return instanceExpr;
	}
	
	// Both array and class references always refer to types
	eq ClassReference.getTypeArgument().nameType() = NameType.TYPE_NAME;
	eq ConstructorReference.getTypeAccess().nameType() = NameType.TYPE_NAME;
	
	// Required for diamond type inference to work
	syn lazy TypeDecl ConstructorReferenceAccess.assignConvertedType() {
		return targetDescriptor.method.type();
	}
	
	syn lazy TypeDecl ParConstructorReferenceAccess.assignConvertedType() {
		return targetDescriptor.method.type();
	}
	
	eq ConstructorReferenceAccess.getAccess().assignConvertedType() {
		return targetDescriptor.method.type();
	}
	
	eq ClassReference.toClass().assignConvertedType() {
		return targetInterface().functionDescriptor().method.type();
	}
}