/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2016, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

aspect GenerateClassfile {
  public void Program.generateClassfile() {
    for (Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit cu = (CompilationUnit) iter.next();
      cu.generateClassfile();
    }
  }

  public void CompilationUnit.generateClassfile() {
    if (fromSource()) {
      for (int i = 0; i < getNumTypeDecl(); i++) {
        getTypeDecl(i).generateClassfile();
        getTypeDecl(i).clear();
      }
    }
  }

  public void TypeDecl.generateClassfile() {
    for (TypeDecl typeDecl : nestedTypes) {
      typeDecl.generateClassfile();
    }
  }

  syn int TypeDecl.magicHeader() = 0xCAFEBABE;
  syn int TypeDecl.minorVersion() = 0;
  syn int TypeDecl.majorVersion() = 48;

  public void ClassDecl.generateClassfile() {
    super.generateClassfile();
    String fileName = destinationPath();
    if (program().options().verbose()) {
      System.out.println("Writing class file to " + fileName);
    }
    try {
      ConstantPool cp = constantPool();

      // Force building of constant pool.
      cp.addClass(constantPoolName());
      if (hasSuperclass()) {
        cp.addClass(superclass().constantPoolName());
      }
      int numInterfaces = 0;
      for (Iterator<TypeDecl> iter = interfacesIterator(); iter.hasNext(); numInterfaces++) {
        cp.addClass(iter.next().constantPoolName());
      }
      for (FieldDeclarator field : fieldDeclarations()) {
        cp.addUtf8(field.name());
        cp.addUtf8(field.type().typeDescriptor());
        field.attributes();
      }
      // Add fields to store enclosing variables.
      for (Variable var : enclosingVariables()) {
        cp.addUtf8("val$" + var.name());
        cp.addUtf8(var.type().typeDescriptor());
      }
      if (needsEnclosing()) {
        cp.addUtf8("this$0");
        cp.addUtf8(enclosing().typeDescriptor());
        cp.addUtf8("Synthetic");
      }
      for (BodyDecl method : methodsAndConstructors()) {
        method.touchMethod(cp);
      }
      if (hasClinit()) {
        cp.addUtf8("<clinit>");
        cp.addUtf8("()V");
        clinit_attributes();
      }
      attributes();

      // Actual ClassFile generation.
      File dest = new File(fileName);
      File parentFile = dest.getParentFile();
      if (parentFile != null) {
        parentFile.mkdirs();
      }
      FileOutputStream f = new FileOutputStream(fileName);
      DataOutputStream out = new DataOutputStream(new BufferedOutputStream(f));
      out.writeInt(magicHeader());
      out.writeChar(minorVersion());
      out.writeChar(majorVersion());
      cp.emit(out);
      int flags = flags();
      if (isNestedType()) {
        flags = mangledFlags(flags);
      }
      flags |= Modifiers.ACC_SUPER;
      out.writeChar(flags);
      out.writeChar(cp.addClass(constantPoolName()));
      out.writeChar(hasSuperclass() ? cp.addClass(superclass().constantPoolName()) : 0);
      out.writeChar(numInterfaces);
      for (Iterator<TypeDecl> iter = interfacesIterator(); iter.hasNext(); ) {
        out.writeChar(cp.addClass(iter.next().constantPoolName()));
      }
      generateFields(out, cp);
      if (needsEnclosing()) {
        out.writeChar(0);
        out.writeChar(cp.addUtf8("this$0"));
        out.writeChar(cp.addUtf8(enclosing().typeDescriptor()));
        out.writeChar(1);
        new SyntheticAttribute(cp).emit(out);
      }

      Collection<BodyDecl> methods = methodsAndConstructors();
      out.writeChar(methods.size() + (hasClinit() ? 1 : 0));
      for (BodyDecl b : methods) {
        b.generateMethod(out, cp);
      }

      if (hasClinit()) {
        out.writeChar(Modifiers.ACC_STATIC);
        out.writeChar(cp.addUtf8("<clinit>"));
        out.writeChar(cp.addUtf8("()V"));
        out.writeChar(clinit_attributes().size());
        for (Attribute attribute : clinit_attributes()) {
          attribute.emit(out);
        }
      }
      out.writeChar(attributes().size());
      for (Attribute attribute : attributes()) {
        attribute.emit(out);
      }
      out.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  /** Generate bytecode attributes for the fields in this type. */
  protected void TypeDecl.generateFields(DataOutputStream out, ConstantPool cp) throws IOException {
    Collection<FieldDeclarator> fields = fieldDeclarations();
    out.writeChar(fields.size() + (needsEnclosing() ? 1 : 0) + enclosingVariables().size());
    for (FieldDeclarator field : fields) {
      out.writeChar(field.flags());
      out.writeChar(cp.addUtf8(field.name()));
      out.writeChar(cp.addUtf8(field.type().typeDescriptor()));
      out.writeChar(field.attributes().size());
      for (Attribute attribute : field.attributes()) {
        attribute.emit(out);
      }
    }
    // Add fields to store enclosing variables.
    for (Variable var : enclosingVariables()) {
      out.writeChar(Modifiers.ACC_FINAL | Modifiers.ACC_SYNTHETIC);
      out.writeChar(cp.addUtf8("val$" + var.name()));
      out.writeChar(cp.addUtf8(var.type().typeDescriptor()));
      out.writeChar(0);
    }
  }

  public void InterfaceDecl.generateClassfile() {
    super.generateClassfile();
    String fileName = destinationPath();
    if (program().options().verbose()) {
      System.out.println("Writing class file to " + fileName);
    }
    try {
      ConstantPool cp = constantPool();
      // Force building of constant pool.
      cp.addClass(constantPoolName());
      cp.addClass("java/lang/Object");
      for (int i = 0; i < getNumSuperInterface(); i++) {
        cp.addClass(getSuperInterface(i).type().constantPoolName());
      }
      for (FieldDeclarator field : fieldDeclarations()) {
        cp.addUtf8(field.name());
        cp.addUtf8(field.type().typeDescriptor());
        field.attributes();
      }
      for (BodyDecl obj : methodsAndConstructors()) {
        if (obj instanceof MethodDecl) {
          MethodDecl method = (MethodDecl) obj;
          cp.addUtf8(method.name());
          cp.addUtf8(method.descName());
          method.attributes();
        }
      }
      attributes();

      if (hasClinit()) {
        cp.addUtf8("<clinit>");
        cp.addUtf8("()V");
        clinit_attributes();
      }

      // Actual classfile generation.
      File dest = new File(fileName);
      File parentFile = dest.getParentFile();
      if (parentFile != null) {
        parentFile.mkdirs();
      }

      FileOutputStream f = new FileOutputStream(fileName);
      DataOutputStream out = new DataOutputStream(new BufferedOutputStream(f));
      out.writeInt(magicHeader());
      out.writeChar(minorVersion());
      out.writeChar(majorVersion());
      cp.emit(out);
      int flags = flags();
      if (isNestedType()) {
        flags = mangledFlags(flags);
      }
      if (isInterfaceDecl()) {
        flags |= Modifiers.ACC_INTERFACE;
      }
      out.writeChar(flags);
      out.writeChar(cp.addClass(constantPoolName()));
      out.writeChar(cp.addClass("java/lang/Object"));
      if (getNumSuperInterface() == 1 && getSuperInterface(0).type().isObject()) {
        out.writeChar(0);
      } else {
        out.writeChar(getNumSuperInterface());
      }
      for (int i = 0; i < getNumSuperInterface(); i++) {
        TypeDecl typeDecl = getSuperInterface(i).type();
        if (typeDecl.isInterfaceDecl()) {
          out.writeChar(cp.addClass(typeDecl.constantPoolName()));
        }
      }
      Collection<FieldDeclarator> fields = fieldDeclarations();
      out.writeChar(fields.size());
      for (FieldDeclarator field : fields) {
        out.writeChar(field.flags());
        out.writeChar(cp.addUtf8(field.name()));
        out.writeChar(cp.addUtf8(field.type().typeDescriptor()));
        out.writeChar(field.attributes().size());
        for (Attribute attribute : field.attributes()) {
          attribute.emit(out);
        }
      }
      Collection<BodyDecl> methods = methodsAndConstructors();
      out.writeChar(methods.size() + (hasClinit() ? 1 : 0));
      for (BodyDecl b : methods) {
        b.generateMethod(out, cp);
      }
      if (hasClinit()) {
        out.writeChar(Modifiers.ACC_STATIC);
        out.writeChar(cp.addUtf8("<clinit>"));
        out.writeChar(cp.addUtf8("()V"));
        out.writeChar(clinit_attributes().size());
        for (Attribute attribute : clinit_attributes()) {
          attribute.emit(out);
        }
      }
      out.writeChar(attributes().size());
      for (Attribute attribute : attributes()) {
        attribute.emit(out);
      }
      out.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void BodyDecl.generateMethod(DataOutputStream out, ConstantPool cp) throws IOException {
  }

  public void MethodDecl.generateMethod(DataOutputStream out, ConstantPool cp) throws IOException {
    out.writeChar(flags());
    out.writeChar(cp.addUtf8(name()));
    out.writeChar(cp.addUtf8(descName()));
    out.writeChar(attributes().size());
    for (Attribute attribute : attributes()) {
      attribute.emit(out);
    }
  }

  public void ConstructorDecl.generateMethod(DataOutputStream out, ConstantPool cp)
      throws IOException {
    out.writeChar(flags());
    out.writeChar(cp.addUtf8("<init>"));
    out.writeChar(cp.addUtf8(descName()));
    out.writeChar(attributes().size());
    for (Attribute attribute : attributes()) {
      attribute.emit(out);
    }
  }

  public void BodyDecl.touchMethod(ConstantPool cp) {
  }

  public void MethodDecl.touchMethod(ConstantPool cp) {
    cp.addUtf8(name());
    cp.addUtf8(descName());
    attributes();
  }

  public void ConstructorDecl.touchMethod(ConstantPool cp) {
    cp.addUtf8("<init>");
    cp.addUtf8(descName());
    attributes();
  }

  /** @return a collection of the fields declared in this type. */
  syn lazy Collection<FieldDeclarator> TypeDecl.fieldDeclarations() = Collections.emptyList();

  eq ReferenceType.fieldDeclarations() {
    Collection<FieldDeclarator> fields = new ArrayList<FieldDeclarator>();
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl.isField()) {
        fields.addAll(decl.fieldDeclarations());
      }
    }
    return fields;
  }

  /**
   * @return all fields declared in this body decl
   */
  syn Collection<FieldDeclarator> BodyDecl.fieldDeclarations() = Collections.emptyList();

  eq FieldDecl.fieldDeclarations() {
    Collection<FieldDeclarator> fields = new ArrayList<FieldDeclarator>();
    for (FieldDeclarator decl : getDeclaratorList()) {
      fields.add(decl);
    }
    return fields;
  }

  /** @return a collection of the methods and constructors declared in this type. */
  syn Collection<BodyDecl> ReferenceType.methodsAndConstructors() {
    Collection<BodyDecl> methods = new ArrayList<BodyDecl>();
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl.isMethodOrConstructor()) {
        methods.add(decl);
      }
    }
    return methods;
  }

  eq ClassDecl.methodsAndConstructors() {
    Collection<BodyDecl> methods = new ArrayList<BodyDecl>();
    if (hasImplicitConstructor()) {
      methods.add(getImplicitConstructor());
    }
    methods.addAll(super.methodsAndConstructors());
    return methods;
  }

  syn boolean BodyDecl.isField() = false;

  eq FieldDecl.isField() = true;

  syn boolean BodyDecl.isMethodOrConstructor() = false;

  eq MethodDecl.isMethodOrConstructor() = true;

  eq ConstructorDecl.isMethodOrConstructor() = true;

  // Remove method bodies and cached attributes after the class file has been generated.
  public boolean ASTNode.clear() {
    boolean empty = true;
    for (int i = 0; i < getNumChild(); i++) {
      ASTNode child = getChild(i);
      if (!child.clear()) {
        empty = false;
      } else {
        if (child instanceof List) {
          ((ASTNode) this).setChild(new List(), i);
        } else if (child instanceof Opt) {
          ((ASTNode) this).setChild(new Opt(), i);
        }
      }
    }
    if (empty) {
      setParent(null);
    }
    if (flush()) {
      flushCache();
    }
    return empty;
  }

  syn boolean ASTNode.flush() = true;

  eq TypeDecl.flush() = false;
  eq LocalClassDeclStmt.flush() = true;
  eq AnonymousDecl.flush() = true;

  eq MethodDecl.flush() = false;
  eq Declarator.flush() = false;
  eq ConstructorDecl.flush() = false;

  public boolean TypeDecl.clear() {
    bytecodes(constantPool()).clearCodeGeneration();
    for (int i = 0; i < getNumBodyDecl(); i++) {
      getBodyDecl(i).clear();
    }
    attributes_computed = false;
    attributes_value = null;
    clinit_attributes_computed = false;
    clinit_attributes_value = null;
    constantPool_computed = false;
    constantPool_value = null;
    bytecodes_ConstantPool_values = null;
    return false;
  }

  public boolean LocalClassDeclStmt.clear() {
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).clear();
    }
    setParent(null);
    flushCache();
    return true;
  }

  public boolean AnonymousDecl.clear() {
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).clear();
    }
    setParent(null);
    flushCache();
    return true;
  }

  public boolean MethodDecl.clear() {
    if (hasBlock()) {
      getBlock().clear();
      setBlock(new Block(new List()));
    }
    bytecodes_ConstantPool_values = null;
    return false;
  }

  public boolean Declarator.clear() {
    return false;
  }

  public boolean FieldDecl.clear() {
    // Avoid flushing so that we keep modifiers during code gen.
    return false;
  }

  public boolean ConstructorDecl.clear() {
    getBlock().clear();
    setBlock(new Block(new List()));
    bytecodes_ConstantPool_values = null;
    return false;
  }
}
