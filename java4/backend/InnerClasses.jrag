/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2016, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

aspect InnerClasses {
  // Not an attribute since needed in phases when the AST has been modified.
  public boolean TypeDecl.hasField(String name) {
    if (!memberFields(name).isEmpty()) {
      return true;
    }
    // TODO(joqvist): use memberFields() instead?
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl instanceof FieldDecl) {
        if (((FieldDecl) decl).hasField(name)) {
          return true;
        }
      }
    }
    return false;
  }

  public boolean FieldDecl.hasField(String name) {
    for (FieldDeclarator decl : getDeclaratorList()) {
      if (decl.name().equals(name)) {
        return true;
      }
    }
    return false;
  }

  private TypeDecl VarAccess.fieldQualifierType() {
    if (hasPrevExpr()) {
      return prevExpr().type();
    }
    TypeDecl typeDecl = hostType();
    while (typeDecl != null && !typeDecl.hasField(name())) {
      typeDecl = typeDecl.enclosingType();
    }
    if (typeDecl != null) {
      return typeDecl;
    }
    return decl().hostType();
  }

  public boolean TypeDecl.hasMethod(String id) {
    if (!memberMethods(id).isEmpty()) {
      return true;
    }
    for (int i = 0; i < getNumBodyDecl(); i++) {
      if (getBodyDecl(i) instanceof MethodDecl) {
        MethodDecl decl = (MethodDecl) getBodyDecl(i);
        if (decl.name().equals(id)) {
          return true;
        }
      }
    }
    return false;
  }

  private TypeDecl MethodAccess.methodQualifierType() {
    if (hasPrevExpr()) {
      return prevExpr().type();
    }
    TypeDecl typeDecl = hostType();
    while (typeDecl != null && !typeDecl.hasMethod(name())) {
      typeDecl = typeDecl.enclosingType();
    }
    if (typeDecl != null) {
      return typeDecl;
    }
    return decl().hostType();
  }


  // Helpers for arrays.
  inh TypeDecl ArrayInit.expectedType();

  eq Program.getChild().expectedType() = null;

  eq ArrayCreationExpr.getArrayInit().expectedType() = type().componentType();
  eq Declarator.getInit().expectedType() = type().componentType();
  eq ArrayInit.getInit().expectedType() = expectedType().componentType();

  syn lazy int ArrayCreationExpr.numArrays() {
    int i = type().dimension();
    Access a = getTypeAccess();
    while (a instanceof ArrayTypeAccess && !(a instanceof ArrayTypeWithSizeAccess)) {
      i--;
      a = ((ArrayTypeAccess) a).getAccess();
    }
    return i;
  }

  syn TypeDecl TypeDecl.stringPromotion() = this;
  eq ReferenceType.stringPromotion() = typeObject();
  eq NullType.stringPromotion() = typeObject();
  eq ByteType.stringPromotion() = typeInt();
  eq ShortType.stringPromotion() = typeInt();

  syn boolean ASTNode.isStringAdd() = false;
  eq AddExpr.isStringAdd() = type().isString() && !isConstant();

  syn boolean AddExpr.firstStringAddPart() = type().isString() && !getLeftOperand().isStringAdd();
  syn boolean AddExpr.lastStringAddPart() = !getParent().isStringAdd();

  syn MethodDecl TypeDecl.methodWithArgs(String name, TypeDecl[] args) {
    for (MethodDecl m : memberMethods(name)) {
      if (m.getNumParameter() == args.length) {
        for (int i = 0; i < args.length; i++) {
          if (m.getParameter(i).type() == args[i]) {
            return m;
          }
        }
      }
    }
    return null;
  }

  protected TypeDecl Access.superConstructorQualifier(TypeDecl targetEnclosingType) {
    TypeDecl enclosing = hostType();
    while (!enclosing.instanceOf(targetEnclosingType)) {
      enclosing = enclosing.enclosingType();
    }
    return enclosing;
  }

  public TypeDecl MethodAccess.superAccessorTarget() {
    TypeDecl targetDecl = prevExpr().type();
    TypeDecl enclosing = hostType();
    do {
      enclosing = enclosing.enclosingType();
    } while (!enclosing.instanceOf(targetDecl));
    return enclosing;
  }

  // The set of TypeDecls that has this TypeDecl as their directly enclosing TypeDecl.
  // I.e., NestedTypes, InnerTypes, AnonymousClasses, LocalClasses.
  public Collection<TypeDecl> TypeDecl.nestedTypes = new RobustLinkedList<TypeDecl>();

  public void TypeDecl.addNestedType(TypeDecl typeDecl) {
    if (typeDecl != this) {
      nestedTypes.add(typeDecl);
    }
  }

  // The set of nested TypeDecls that are accessed in this TypeDecl.
  public Collection<TypeDecl> TypeDecl.usedNestedTypes = new RobustLinkedList<TypeDecl>();

  public void TypeDecl.addUsedNestedType(TypeDecl typeDecl) {
    usedNestedTypes.add(typeDecl);
  }

  // TODO(joqvist): convert to collection attribute.
  /** Collect the set of variables used in the enclosing class(es). */
  syn lazy Collection<Variable> TypeDecl.enclosingVariables() {
    Collection<Variable> vars = new HashSet<Variable>();
    for (TypeDecl e = this; e != null; e = e.enclosingType()) {
      if (e.isLocalClass() || e.isAnonymous()) {
        collectEnclosingVariables(vars, e.enclosingType());
      }
    }
    if (isClassDecl()) {
      ClassDecl classDecl = (ClassDecl) this;
      if (classDecl.isNestedType() && classDecl.hasSuperclass()) {
        vars.addAll(classDecl.superclass().enclosingVariables());
      }
    }
    return vars;
  }

  public void ASTNode.collectEnclosingVariables(Collection<Variable> vars, TypeDecl typeDecl) {
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).collectEnclosingVariables(vars, typeDecl);
    }
  }
  public void VarAccess.collectEnclosingVariables(Collection<Variable> vars, TypeDecl typeDecl) {
    Variable v = decl();
    if (!v.isInstanceVariable() && !v.isClassVariable() && v.hostType() == typeDecl) {
      vars.add(v);
    }
    super.collectEnclosingVariables(vars, typeDecl);
  }


  public int TypeDecl.accessorCounter = 0;

  private HashMap<ArrayList<Object>, ASTNode> TypeDecl.accessorMap = null;

  public ASTNode TypeDecl.getAccessor(Object source, String name) {
    ArrayList<Object> key = new ArrayList<Object>(2);
    key.add(source);
    key.add(name);
    if (accessorMap == null || !accessorMap.containsKey(key)) {
      return null;
    }
    return accessorMap.get(key);
  }

  public void TypeDecl.addAccessor(Object source, String name, ASTNode accessor) {
    ArrayList<Object> key = new ArrayList<Object>(2);
    key.add(source);
    key.add(name);
    if (accessorMap == null) {
      accessorMap = new HashMap<ArrayList<Object>, ASTNode>();
    }
    accessorMap.put(key, accessor);
  }

  public ASTNode TypeDecl.getAccessorSource(ASTNode accessor) {
    for (Map.Entry<ArrayList<Object>, ASTNode> entry : accessorMap.entrySet()) {
      if (entry.getValue() == accessor) {
        return (ASTNode) entry.getKey().get(0);
      }
    }
    return null;
  }

  public MethodDecl MethodDecl.createAccessor(TypeDecl methodQualifier) {
    MethodDecl m = (MethodDecl) methodQualifier.getAccessor(this, "method");
    if (m != null) {
      return m;
    }

    int accessorIndex = methodQualifier.accessorCounter++;

    List parameterList = new List();
    for (int i = 0; i < getNumParameter(); i++) {
      parameterList.add(new ParameterDeclaration(
            // We need to create a qualified access in case the
            // method we are generating an access for is not declared
            // in the methodQualifier type.
            getParameter(i).type().createQualifiedAccess(),
            getParameter(i).name()));
    }
    List exceptionList = new List();
    for (int i = 0; i < getNumException(); i++) {
      exceptionList.add((Access) getException(i).treeCopyNoTransform());
    }

    // Add synthetic flag to modifiers.
    Modifiers modifiers = new Modifiers(new List());
    if (getModifiers().isStatic()) {
      modifiers.addModifier(new Modifier("static"));
    }
    modifiers.addModifier(new Modifier("synthetic"));
    modifiers.addModifier(new Modifier("public"));

    // Build accessor declaration.
    m = new MethodDecl(
      modifiers,
      getTypeAccess().type().createQualifiedAccess(),
      name() + "$access$" + accessorIndex,
      parameterList,
      exceptionList,
      new Opt(
        new Block(
          new List().add(
            createAccessorStmt()
          )
        )
      )
    );
    m = methodQualifier.addMemberMethod(m);
    methodQualifier.addAccessor(this, "method", m);
    return m;
  }

  private Stmt MethodDecl.createAccessorStmt() {
    List argumentList = new List();
    for (int i = 0; i < getNumParameter(); i++) {
      argumentList.add(new VarAccess(getParameter(i).name()));
    }
    Access access = new BoundMethodAccess(name(), argumentList, this);
    if (!isStatic()) {
      access = new ThisAccess("this").qualifiesAccess(access);
    }
    return isVoid() ? (Stmt) new ExprStmt(access) : new ReturnStmt(new Opt(access));
  }

  public MethodDecl MethodDecl.createSuperAccessor(TypeDecl methodQualifier) {
    MethodDecl m = (MethodDecl) methodQualifier.getAccessor(this, "method_super");
    if (m != null) {
      return m;
    }

    int accessorIndex = methodQualifier.accessorCounter++;
    List parameters = new List();
    List args = new List();
    for (int i = 0; i < getNumParameter(); i++) {
      parameters.add(new ParameterDeclaration(getParameter(i).type(), getParameter(i).name()));
      args.add(new VarAccess(getParameter(i).name()));
    }
    Stmt stmt;
    if (type().isVoid()) {
      stmt = new ExprStmt(new SuperAccess("super").qualifiesAccess(new MethodAccess(name(), args)));
    } else {
      stmt = new ReturnStmt(new Opt(new SuperAccess("super")
            .qualifiesAccess(new MethodAccess(name(), args))));
    }
    m = new MethodDecl(
      new Modifiers(new List().add(new Modifier("synthetic"))),
      type().createQualifiedAccess(),
      name() + "$access$" + accessorIndex,
      parameters,
      new List(),
      new Opt(
        new Block(
          new List().add(stmt)
        )
      )
    );
    m = methodQualifier.addMemberMethod(m);
    methodQualifier.addAccessor(this, "method_super", m);
    return m;
  }

  /** Adds an accessor method for this field. */
  protected static MethodDecl ASTNode.createFieldAccessor(Variable field, TypeDecl fieldQualifier) {
    MethodDecl m = (MethodDecl) fieldQualifier.getAccessor(field, "field_read");
    if (m != null) {
      return m;
    }

    int accessorIndex = fieldQualifier.accessorCounter++;
    Modifiers modifiers = new Modifiers(new List<Modifier>(
        new Modifier("static"),
        new Modifier("synthetic"),
        new Modifier("public")));

    List<ParameterDeclaration> parameters = new List<ParameterDeclaration>();
    if (!field.isStatic()) {
      parameters.add(new ParameterDeclaration(fieldQualifier.createQualifiedAccess(), "that"));
    }

    m = new MethodDecl(
      modifiers,
      field.type().createQualifiedAccess(),
      "get$" + field.name() + "$access$" + accessorIndex,
      parameters,
      new List<Access>(),
      new Opt<Block>(new Block(new List<Stmt>(new ReturnStmt(createAccess(field))))));
    m = fieldQualifier.addMemberMethod(m);
    fieldQualifier.addAccessor(field, "field_read", m);
    return m;
  }

  /** Adds an accessor method to write this field. */
  protected static MethodDecl ASTNode.createFieldAccessorWrite(Variable field,
      TypeDecl fieldQualifier) {
    MethodDecl m = (MethodDecl) fieldQualifier.getAccessor(field, "field_write");
    if (m != null) {
      return m;
    }

    int accessorIndex = fieldQualifier.accessorCounter++;
    Modifiers modifiers = new Modifiers(new List<Modifier>(
        new Modifier("static"),
        new Modifier("synthetic"),
        new Modifier("public")));

    List<ParameterDeclaration> parameters = new List<ParameterDeclaration>();
    if (!field.isStatic()) {
      parameters.add(new ParameterDeclaration(fieldQualifier.createQualifiedAccess(), "that"));
    }
    parameters.add(new ParameterDeclaration(field.type().createQualifiedAccess(), "value"));

    m = new MethodDecl(
      modifiers,
      field.type().createQualifiedAccess(),
      "set$" + field.name() + "$access$" + accessorIndex,
      parameters,
      new List<Access>(),
      new Opt<Block>(
        new Block(new List<Stmt>(
            new ExprStmt(new AssignSimpleExpr(createAccess(field), new VarAccess("value"))),
            new ReturnStmt(new Opt<Expr>(new VarAccess("value")))))));
    m = fieldQualifier.addMemberMethod(m);
    fieldQualifier.addAccessor(field, "field_write", m);
    return m;
  }

  protected static Access ASTNode.createAccess(Variable var) {
    if (var instanceof FieldDeclarator) {
      return ((FieldDeclarator) var).createAccess();
    } else {
      throw new Error("Trying to create accessor for non-field.");
    }
  }

  protected Access FieldDeclarator.createAccess() {
    Access fieldAccess = new BoundFieldAccess(this);
    return isStatic() ? fieldAccess : new VarAccess("that").qualifiesAccess(fieldAccess);
  }

  syn boolean VarAccess.requiresAccessor() {
    Variable v = decl();
    if (!(v instanceof FieldDeclarator)) {
      return false;
    }
    FieldDeclarator f = (FieldDeclarator) v;
    if (f.isPrivate() && !hostType().hasField(v.name())) {
      return true;
    }
    if (f.isProtected() && !f.hostPackage().equals(hostPackage())
        && !hostType().hasField(v.name())) {
      return true;
    }
    return false;
  }

  syn boolean MethodAccess.requiresAccessor() {
    MethodDecl m = decl();
    if (m.isPrivate() && m.hostType() != hostType()) {
      return true;
    }
    if (m.isProtected() && !m.hostPackage().equals(hostPackage())
        && !hostType().hasMethod(m.name())) {
      return true;
    }
    return false;
  }

  syn boolean ClassInstanceExpr.isAnonymousInNonStaticContext() {
    return !unqualifiedScope().inStaticContext()
        && (!inExplicitConstructorInvocation() || enclosingBodyDecl().hostType().isInnerType());
  }

  /**
   * Finds the directly enclosing class instance expression, i.e. the expression
   * defining this type. Throws an error if this type is not defined by a class instance
   * expression.
   */
  inh ClassInstanceExpr TypeDecl.classInstanceExpression();

  eq Program.getChild().classInstanceExpression() {
    throw new Error("Missing enclosing class instance.");
  }

  eq ClassInstanceExpr.getChild().classInstanceExpression() = this;

  syn lazy boolean TypeDecl.needsEnclosing() {
    if (isAnonymous()) {
      return classInstanceExpression().isAnonymousInNonStaticContext();
    } else if (isLocalClass()) {
      return !inStaticContext();
    } else if (isInnerType()) {
      return true;
    }
    return false;
  }

  syn lazy boolean TypeDecl.needsSuperEnclosing() {
    if (!isAnonymous()) {
      return false;
    }
    TypeDecl superClass = ((ClassDecl) this).superclass();
    if (superClass.isLocalClass()) {
      return !superClass.inStaticContext();
    } else if (superClass.isInnerType()) {
      return true;
    } if (needsEnclosing() && enclosing() == superEnclosing()) {
      return false;
    }
    return false;
  }

  syn TypeDecl TypeDecl.enclosing() {
    if (!needsEnclosing()) {
      return null;
    }
    TypeDecl typeDecl = enclosingType();
    if (isAnonymous() && inExplicitConstructorInvocation()) {
      typeDecl = typeDecl.enclosingType();
    }
    return typeDecl;
  }

  syn TypeDecl TypeDecl.superEnclosing() = null;
  eq ClassDecl.superEnclosing() = superclass().enclosing();

  syn boolean ConstructorDecl.needsEnclosing() = hostType().needsEnclosing();
  syn boolean ConstructorDecl.needsSuperEnclosing() = hostType().needsSuperEnclosing();

  syn TypeDecl ConstructorDecl.enclosing() = hostType().enclosing();
  syn TypeDecl ConstructorDecl.superEnclosing() = hostType().superEnclosing();

  // Add val$name as fields to the class.
  private boolean TypeDecl.addEnclosingVariables = true;

  public void TypeDecl.addEnclosingVariables() {
    if (!addEnclosingVariables) {
      return;
    }
    addEnclosingVariables = false;
    for (Variable v : enclosingVariables()) {
      Modifiers m = new Modifiers();
      m.addModifier(new Modifier("public"));
      m.addModifier(new Modifier("synthetic"));
      m.addModifier(new Modifier("final"));
      FieldDeclarator decl = new FieldDeclarator(
          "val$" + v.name(), new List<Dims>(), new Opt<Expr>());
      addMemberField(new FieldDecl(
          m,
          v.type().createQualifiedAccess(),
          new List<FieldDeclarator>(decl)));
    }
  }

  // Add val$name as parameters to the constructor.
  protected boolean ConstructorDecl.addEnclosingVariables = true;

  public void ConstructorDecl.addEnclosingVariables() {
    if (!addEnclosingVariables) {
      return;
    }
    addEnclosingVariables = false;
    hostType().addEnclosingVariables();
    for (Variable v : hostType().enclosingVariables()) {
      getParameterList().add(new ParameterDeclaration(v.type(), "val$" + v.name()));
    }
  }

  // Add val$name as arguments to the constructor.
  protected boolean ConstructorAccess.addEnclosingVariables = true;
  public void ConstructorAccess.addEnclosingVariables() {
    if (!addEnclosingVariables) {
      return;
    }
    addEnclosingVariables = false;
    decl().addEnclosingVariables();
    for (Variable v : decl().hostType().enclosingVariables()) {
      getArgList().add(new VarAccess("val$" + v.name()));
    }
  }

  // Add val$name as arguments to the constructor.
  protected boolean ClassInstanceExpr.addEnclosingVariables = true;
  public void ClassInstanceExpr.addEnclosingVariables() {
    if (!addEnclosingVariables) {
      return;
    }
    addEnclosingVariables = false;
    decl().addEnclosingVariables();
    for (Variable v : decl().hostType().enclosingVariables()) {
      getArgList().add(new VarAccess(v.name()));
    }
  }

  public ConstructorDecl ConstructorDecl.createAccessor() {
    ConstructorDecl c = (ConstructorDecl) hostType().getAccessor(this, "constructor");
    if (c != null) {
      return c;
    }

    // Make sure enclosing varibles are added as parameters prior to building accessor.
    addEnclosingVariables();

    Modifiers modifiers = new Modifiers(new List<Modifier>(
        new Modifier("synthetic"),
        new Modifier("public")));

    List<ParameterDeclaration> parameters = createAccessorParameters();

    List exceptionList = new List();
    for (int i = 0; i < getNumException(); i++) {
      exceptionList.add(getException(i).type().createQualifiedAccess());
    }

    // Add all parameters as arguments except for the dummy parameter.
    List args = new List();
    for (int i = 0; i < parameters.getNumChildNoTransform() - 1; i++) {
      args.add(new VarAccess(((ParameterDeclaration) parameters.getChildNoTransform(i)).name()));
    }
    ConstructorAccess access = new ConstructorAccess("this", args);
    access.addEnclosingVariables = false;

    c = new ConstructorDecl(
      modifiers,
      name(),
      parameters,
      exceptionList,
      new Opt(
        new ExprStmt(
          access
        )
      ),
      new Block()
    );
    c = hostType().addConstructor(c);
    c.addEnclosingVariables = false;
    hostType().addAccessor(this, "constructor", c);
    return c;
  }

  protected List<ParameterDeclaration> ConstructorDecl.createAccessorParameters() {
    List<ParameterDeclaration> parameters = new List();
    for (int i = 0; i < getNumParameter(); i++) {
      parameters.add(new ParameterDeclaration(getParameter(i).type(), getParameter(i).name()));
    }
    parameters.add(new ParameterDeclaration(
          createAnonymousJavaTypeDecl().createBoundAccess(),
          "p" + getNumParameter()));
    return parameters;
  }

  protected TypeDecl ConstructorDecl.createAnonymousJavaTypeDecl() {
    ClassDecl classDecl =
        new ClassDecl(
            new Modifiers(new List().add(new Modifier("synthetic"))),
            "" + hostType().nextAnonymousIndex(),
            new Opt(),
            new List(),
            new List()
            );
    classDecl = hostType().addMemberClass(classDecl);
    hostType().addNestedType(classDecl);
    return classDecl;
  }
}
