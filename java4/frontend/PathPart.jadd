import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;

/**
 * PathPart classes are used to represent parts of the bootclasspath and user
 * classpath.
 */
aspect PathPart {

  /**
   * Represents a compilation unit/class source file. A ClassSource can be used
   * to parse a compilation unit containing the class.
   */
  public abstract class ClassSource {
    protected final PathPart sourcePath;

    /**
     * Used to represent an non-existent compilation unit source file.
     *
     * <p>This class source should never be used to attempt to load a class, it
     * is simply used as a marker to indicate failure to find a compilation
     * unit.
     */
    public static final ClassSource NONE = new ClassSource(null) {
      @Override
      public long getAge() {
        return 0;
      }
      @Override
      public InputStream openInputStream() {
        throw new UnsupportedOperationException(
            "ClassSource.NONE can not open an input stream!");
      }
      @Override
      public String pathName() {
        return "<Unknown Source>";
      }
    };

    public ClassSource(PathPart sourcePath) {
      this.sourcePath = sourcePath;
    }

    public PathPart getSourcePath() {
      return sourcePath;
    }

    /**
     * @return Last modification time of the class source.
     */
    abstract public long getAge();

    /**
     * @return Input stream pointing to the class source.
     */
    abstract public InputStream openInputStream() throws IOException;

    /**
     * It is sufficient to only overload pathName if sourceName=pathName
     * @return the full name of the class source (e.g. file path).
     */
    public String sourceName() {
      return pathName();
    }

    /**
     * @return the path to the source file or the enclosing jar file
     */
    abstract public String pathName();

    /**
     * It is sufficient to only overload pathName if relativeName = pathName
     * @return the path to the source file, or the path to the file inside a
     * jar file
     */
    public String relativeName() {
      return pathName();
    }

    @Override
    public String toString() {
      return sourceName();
    }

    /**
     * Parses the compilation unit from this class source.
     *
     * NB only call this once! The input stream is closed after the compilation
     * unit is parsed.
     *
     * @return parsed compilation unit, or {@code null} if something failed
     */
    public CompilationUnit parseCompilationUnit(Program program)
      throws IOException {
      InputStream is = openInputStream();
      try {
        if (program.options().verbose()) {
          System.out.print("Loading " + sourceName() + " ");
        }

        long start = System.nanoTime();
        CompilationUnit u = program.javaParser.parse(is, sourceName());
        long elapsed = System.nanoTime() - start;
        program.javaParseTime += elapsed;
        program.numJavaFiles += 1;

        u.setFromSource(true);
        u.setClassSource(this);

        if (program.options().verbose()) {
          System.out.println("in " + (elapsed / 1000000) + " ms");
        }
        return u;
      } catch (Exception e) {
        System.err.println("Unexpected error of kind " + e.getClass().getName());
        throw new Error(sourceName() + ": " + e.getMessage(), e);
      } finally {
        if (is != null) {
          try {
            is.close();
          } catch (IOException e) {
          }
        }
      }
    }
  }

  public class FileClassSource extends ClassSource {
    private final String filePath;

    public FileClassSource(PathPart sourcePath, String path) {
      super(sourcePath);
      this.filePath = path;
    }

    @Override
    public long getAge() {
      // last modification time computed only if needed
      File file = new File(filePath);
      return file.lastModified();
    }

    @Override
    public InputStream openInputStream() throws IOException {
      File file = new File(filePath);
      return new FileInputStream(file);
    }

    @Override
    public String pathName() {
      return filePath;
    }
  }

  /**
   * Represents a bytecode class source (.class file).
   */
  public abstract class BytecodeClassSource extends ClassSource {
    public BytecodeClassSource(PathPart sourcePath) {
      super(sourcePath);
    }

    @Override
    public CompilationUnit parseCompilationUnit(Program program)
      throws IOException {
      InputStream is = openInputStream();
      try {
        if (program.options().verbose()) {
          System.out.print("Loading " + sourceName() + " ");
        }

        long start = System.nanoTime();
        CompilationUnit u = program.bytecodeReader.read(is, sourceName(), program);
        long elapsed = System.nanoTime() - start;
        program.bytecodeParseTime += elapsed;
        program.numClassFiles += 1;

        u.setFromSource(false);
        u.setClassSource(this);

        if (program.options().verbose()) {
          System.out.println(" in " + (elapsed / 1000000) + " ms");
        }
        return u;
      } catch (Exception e) {
        throw new Error("Error loading " + sourceName(), e);
      } finally {
        if (is != null) {
          try {
            is.close();
          } catch (IOException e) {
          }
        }
      }
    }
  }

  public class FileBytecodeClassSource extends BytecodeClassSource {
    private final String filePath;

    public FileBytecodeClassSource(PathPart sourcePath, String path) {
      super(sourcePath);
      this.filePath = path;
    }

    @Override
    public long getAge() {
      // last modification time computed only when needed
      File file = new File(filePath);
      return file.lastModified();
    }

    @Override
    public InputStream openInputStream() throws IOException {
      File file = new File(filePath);
      return new FileInputStream(file);
    }

    @Override
    public String pathName() {
      return filePath;
    }
  }

  public class JarClassSource extends BytecodeClassSource {
    private final ZipFile jar;
    private final String name;

    public JarClassSource(PathPart sourcePath, ZipFile jar, String name) {
      super(sourcePath);
      this.jar = jar;
      this.name = name;
    }

    public String jarFilePath() {
      return jar.getName();
    }

    @Override
    public long getAge() {
      // last modification time computed only when needed
      ZipEntry entry = jar.getEntry(name);
      return entry.getTime();
    }

    @Override
    public InputStream openInputStream() throws IOException {
      ZipEntry entry = jar.getEntry(name);
      return jar.getInputStream(entry);
    }

    @Override
    public String pathName() {
      return jar.getName();
    }

    @Override
    public String relativeName() {
      return name;
    }

    @Override
    public String sourceName() {
      return pathName() + ":" + relativeName();
    }
  }

  /**
   * Abstract representation of a collection of class sources.
   */
  public abstract class PathPart {
    /**
     * This is {@code true} if this path part represents a source path, {@code
     * true} if this path part represents a bytecode class path.
     */
    protected final boolean isSource;

    /**
     * The file suffix of source files in this path part.
     */
    protected final String fileSuffix;

    protected PathPart(boolean isSource) {
      this.isSource = isSource;
      this.fileSuffix = isSource ? ".java" : ".class";
    }

    /**
     * @return the set of all available packages in this path part
     */
    abstract public Collection<String> packages();

    public static PathPart createSourcePath(String fileName) {
      return createPathPart(fileName, true);
    }

    public static PathPart createClassPath(String fileName) {
      return createPathPart(fileName, false);
    }

    private static PathPart createPathPart(String source, boolean fromSource) {
      try {
        File file = new File(source);
        if (file.isDirectory()) {
          return new FolderPath(file, fromSource);
        } else if (file.isFile()) {
          return new JarFilePath(file);
        }
      } catch (IOException e) {
        System.err.println("Warning: can not open class path " + source);
      }
      return null;
    }

    /**
     * Retrieves a compilation unit based on the canonical name.
     * @param name the canonical name of the class to lookup
     * @return {@code null} if a compilation unit with the given name is not
     * available in this PathPart.
     */
    public ClassSource findSource(String name) {
      return ClassSource.NONE;
    }

    /**
     * Load the compilation unit of a class.
     * @param program
     * @param name The canonical name of the class.
     */
    public CompilationUnit getCompilationUnit(Program program, String name)
      throws IOException {
      return findSource(name).parseCompilationUnit(program);
    }
  }

  /**
   * A folder path listed in the classpath. Can contain many .java or .class
   * files.
   */
  public class FolderPath extends PathPart {
    /**
     * The root folder of this path part.
     */
    private final File folder;
    private final Collection<String> packages = new LinkedList<String>();

    public FolderPath(File folder, boolean isSource) {
      super(isSource);
      this.folder = folder;

      scanPackages(folder, "");
    }

    private void scanPackages(File folder, String parent) {
      for (File child: folder.listFiles()) {
        if (child.isDirectory()) {
          String pkgName = parent;
          if (!pkgName.isEmpty()) {
            pkgName += ".";
          }
          pkgName += child.getName();
          packages.add(pkgName);
          scanPackages(child, pkgName);
        }
      }
    }

    @Override
    public Collection<String> packages() {
      return packages;
    }

    @Override
    public ClassSource findSource(String name) {
      String fileName = name.replace('.', File.separatorChar) + fileSuffix;
      File classFile = new File(folder, fileName);
      if (classFile.isFile() && classFile.canRead()) {
        String pathName = classFile.getPath();
        if (isSource) {
          return new FileClassSource(this, pathName);
        } else {
          return new FileBytecodeClassSource(this, pathName);
        }
      }
      return ClassSource.NONE;
    }

    @Override
    public String toString() {
      return folder.getPath();
    }
  }

  /**
   * A Jar file path listed in the classpath. Can contain many .class files.
   */
  public class JarFilePath extends PathPart {
    private final Collection<String> packages = new HashSet<String>();
    private final HashSet<String> entrySet = new HashSet<String>();
    private final ZipFile jar;
    private final String jarPath;

    public JarFilePath(File jarFile) throws IOException {
      super(false);
      this.jar = new ZipFile(jarFile);
      this.jarPath = jar.getName();

      scanJar();
    }

    private void scanJar() {
      // Add all zip entries to a set so that we can quickly check if the Jar
      // contains a given class
      for (Enumeration entries = jar.entries(); entries.hasMoreElements(); ) {
        ZipEntry entry = (ZipEntry) entries.nextElement();
        String path = entry.getName();
        if (entry.isDirectory()) {
          addPackages(path);
        } else if (path.endsWith(fileSuffix)) {
          addPackages(path);
          entrySet.add(path);
        }
      }
    }

    private void addPackages(String path) {
      String canonical = path.replace('/', '.');
      int index = path.lastIndexOf('/', path.length()-1);
      while (index >= 0) {
        if (!packages.add(canonical.substring(0, index))) {
          break;
        }
        index = path.lastIndexOf('/', index-1);
      }
    }

    @Override
    public Collection<String> packages() {
      return packages;
    }

    @Override
    public ClassSource findSource(String name) {
      // ZipFiles always use '/' as separator
      String jarName = name.replace('.', '/') + fileSuffix;
      if (entrySet.contains(jarName)) {
        return new JarClassSource(this, jar, jarName);
      }
      return ClassSource.NONE;
    }

    @Override
    public String toString() {
      return "jar:" + jarPath;
    }
  }

  /**
   * A file specified explicitly on the commandline as a source file.
   * Must point to a .java file.
   */
  public class FilePath extends PathPart {
    private final String fileName;
    private final Collection<String> packages = new LinkedList<String>();

    public FilePath(String path) {
      super(true);
      this.fileName = path;

      scanPackages(path);
    }

    private void scanPackages(String path) {
      // normalize file separators to '/'
      String norm = path.replace(File.separatorChar, '/');
      String canonical = norm.replace('/', '.');
      int index = norm.indexOf('/', 0);
      while (index >= 0) {
        packages.add(canonical.substring(0, index));
        index = norm.indexOf('/', index+1);
      }
    }

    @Override
    public Collection<String> packages() {
      return packages;
    }

    @Override
    public ClassSource findSource(String name) {
      if (fileName.equals(name)) {
        File file = new File(fileName);
        if (file.isFile() && file.canRead()) {
          return new FileClassSource(this, fileName);
        }
      }
      return ClassSource.NONE;
    }

    @Override
    public String toString() {
      return fileName;
    }
  }

}
