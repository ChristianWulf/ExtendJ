/*
 * The JastAdd Extensible Java Compiler (http://jastadd.org) is covered
 * by the modified BSD License. You should have received a copy of the
 * modified BSD license with this compiler.
 *
 * Copyright (c) 2005-2008, Torbjorn Ekman
 * All rights reserved.
 */

import java.io.BufferedInputStream;
import java.io.DataInputStream;

aspect BytecodeReader {

  public class BytecodeParser implements BytecodeReader {
    public CompilationUnit read(InputStream is, String fullName, Program p)
        throws FileNotFoundException, IOException {
      return new BytecodeParser(is, fullName).parse(null, null, p);
    }

    public static final boolean VERBOSE = false;

    private DataInputStream is;
    public CONSTANT_Class_Info classInfo;
    public CONSTANT_Class_Info outerClassInfo;
    public String name;

    public BytecodeParser(InputStream in, String name) {
      this.is = new DataInputStream(new BufferedInputStream(in));
      this.name = name;
    }

    public BytecodeParser() {
      this("");
    }

    public BytecodeParser(String name) {
      if (!name.endsWith(".class")) {
        name = name.replace('.', '/') + ".class";
      }
      this.name = name;
    }

    public int next() throws IOException {
      return is.read();
    }

    public int u1() throws IOException {
      return is.readUnsignedByte();
    }

    public int u2() throws IOException {
      return is.readUnsignedShort();
    }

    public int u4() throws IOException {
      return is.readInt();
    }

    public int readInt() throws IOException {
      return is.readInt();
    }

    public float readFloat() throws IOException {
      return is.readFloat();
    }

    public long readLong() throws IOException {
      return is.readLong();
    }

    public double readDouble() throws IOException {
      return is.readDouble();
    }

    public String readUTF() throws IOException {
      return is.readUTF();
    }

    public void skip(int length) throws IOException {
      while (length > 0) {
        length -= is.skip(length);
      }
    }

    public void error(String s) {
      throw new RuntimeException(s);
    }

    public void print(String s) {
      //System.out.print(s);
    }

    public void println(String s) {
      print(s + "\n");
    }

    public void println() {
      print("\n");
    }

    public CompilationUnit parse(TypeDecl outerTypeDecl, CONSTANT_Class_Info outerClassInfo,
        Program classPath) throws IOException {

      if (BytecodeParser.VERBOSE) {
        println("Parsing byte codes in " + name);
      }

      this.outerClassInfo = outerClassInfo;
      parseMagic();
      parseMinor();
      parseMajor();
      parseConstantPool();
      CompilationUnit cu = new CompilationUnit();
      TypeDecl typeDecl = parseTypeDecl();
      cu.setPackageDecl(classInfo.packageDecl());
      cu.addTypeDecl(typeDecl);
      parseFields(typeDecl);
      parseMethods(typeDecl);
      new Attributes(this, typeDecl, outerTypeDecl, classPath);
      return cu;
    }

    public void parseMagic() throws IOException {
      if (next() != 0xca || next() != 0xfe || next() != 0xba || next() != 0xbe) {
        error("magic error");
      }
    }

    public void parseMinor() throws IOException {
      int low = u1();
      int high = u1();
      if (BytecodeParser.VERBOSE) {
        println("Minor: " + high + "." + low);
      }
    }

    public void parseMajor() throws IOException {
      int low = u1();
      int high = u1();
      if (BytecodeParser.VERBOSE) {
        println("Major: " + high + "." + low);
      }
    }

    public TypeDecl parseTypeDecl() throws IOException {
      int flags = u2();
      Modifiers modifiers = modifiers(flags & 0xfddf);
      if ((flags & 0x0200) == 0) {
        ClassDecl decl = new ClassDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        decl.setSuperClassOpt(superClass == null ? new Opt()
            : new Opt(superClass));
        decl.setImplementsList(parseInterfaces(new List()));
        return decl;
      } else {
        InterfaceDecl decl = new InterfaceDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        decl.setSuperInterfaceList(
            parseInterfaces(
              superClass == null ? new List()
              : new List().add(superClass)));
        return decl;
      }
    }

    public String parseThisClass() throws IOException {
      int index = u2();
      CONSTANT_Class_Info info = (CONSTANT_Class_Info) constantPool[index];
      classInfo = info;
      return info.simpleName();
    }

    public Access parseSuperClass() throws IOException {
      int index = u2();
      if (index == 0) {
        return null;
      }
      CONSTANT_Class_Info info = (CONSTANT_Class_Info) constantPool[index];
      return info.access();
    }

    public List parseInterfaces(List list) throws IOException {
      int count = u2();
      for (int i = 0; i < count; i++) {
        CONSTANT_Class_Info info = (CONSTANT_Class_Info) constantPool[u2()];
        list.add(info.access());
      }
      return list;
    }

    public static Access fromClassName(String s) {
      // Sample ClassName: a/b/c$d$e
      // the package name ends at the last '/'
      // after that follows a list of type names separated by '$'
      // all except the first are nested types

      String packageName = "";
      int index = s.lastIndexOf('/');
      if (index != -1) {
        packageName = s.substring(0, index).replace('/', '.');
      }
      String[] typeNames = s.substring(index + 1).split("\\$");
      Access result = new TypeAccess(packageName, typeNames[0]);
      for (int i = 1; i < typeNames.length; i++) {
        result = result.qualifiesAccess(new TypeAccess(typeNames[i]));
      }
      return result;
    }

    public static Modifiers modifiers(int flags) {
      Modifiers m = new Modifiers();
      if ((flags & 0x0001) != 0) {
        m.addModifier(new Modifier("public"));
      }
      if ((flags & 0x0002) != 0) {
        m.addModifier(new Modifier("private"));
      }
      if ((flags & 0x0004) != 0) {
        m.addModifier(new Modifier("protected"));
      }
      if ((flags & 0x0008) != 0) {
        m.addModifier(new Modifier("static"));
      }
      if ((flags & 0x0010) != 0) {
        m.addModifier(new Modifier("final"));
      }
      if ((flags & 0x0020) != 0) {
        m.addModifier(new Modifier("synchronized"));
      }
      if ((flags & 0x0040) != 0) {
        m.addModifier(new Modifier("volatile"));
      }
      if ((flags & 0x0080) != 0) {
        m.addModifier(new Modifier("transient"));
      }
      if ((flags & 0x0100) != 0) {
        m.addModifier(new Modifier("native"));
      }
      if ((flags & 0x0400) != 0) {
        m.addModifier(new Modifier("abstract"));
      }
      if ((flags & 0x0800) != 0) {
        m.addModifier(new Modifier("strictfp"));
      }
      return m;
    }

    public void parseFields(TypeDecl typeDecl) throws IOException {
      int count = u2();
      if (BytecodeParser.VERBOSE) {
        println("Fields (" + count + "):");
      }
      for (int i = 0; i < count; i++) {
        if (BytecodeParser.VERBOSE) {
          print(" Field nbr " + i + " ");
        }
        FieldInfo fieldInfo = new FieldInfo(this);
        if (!fieldInfo.isSynthetic()) {
          typeDecl.addBodyDecl(fieldInfo.bodyDecl());
        }
      }
    }

    public void parseMethods(TypeDecl typeDecl) throws IOException {
      int count = u2();
      if (BytecodeParser.VERBOSE) {
        println("Methods (" + count + "):");
      }
      for (int i = 0; i < count; i++) {
        if (BytecodeParser.VERBOSE) {
          print("  Method nbr " + i + " ");
        }
        MethodInfo info = new MethodInfo(this);
        if (!info.isSynthetic() && !info.name.equals("<clinit>")) {
          typeDecl.addBodyDecl(info.bodyDecl());
        }
      }
    }

    public CONSTANT_Info[] constantPool = null;

    private void checkLengthAndNull(int index) {
      if (index >= constantPool.length) {
        throw new Error("Trying to access element " + index  + " in constant pool of length " + constantPool.length);
      }
      if (constantPool[index] == null) {
        throw new Error("Unexpected null element in constant pool at index " + index);
      }
    }

    public boolean validConstantPoolIndex(int index) {
      return index < constantPool.length && constantPool[index] != null;
    }

    public CONSTANT_Info getCONSTANT_Info(int index) {
      checkLengthAndNull(index);
      return constantPool[index];
    }

    public CONSTANT_Utf8_Info getCONSTANT_Utf8_Info(int index) {
      checkLengthAndNull(index);
      CONSTANT_Info info = constantPool[index];
      if (!(info instanceof CONSTANT_Utf8_Info)) {
        throw new Error("Expected CONSTANT_Utf8_info at " + index + " in constant pool but found " + info.getClass().getName());
      }
      return (CONSTANT_Utf8_Info) info;
    }

    public CONSTANT_Class_Info getCONSTANT_Class_Info(int index) {
      checkLengthAndNull(index);
      CONSTANT_Info info = constantPool[index];
      if (!(info instanceof CONSTANT_Class_Info)) {
        throw new Error("Expected CONSTANT_Class_info at " + index + " in constant pool but found " + info.getClass().getName());
      }
      return (CONSTANT_Class_Info) info;
    }

    public void parseConstantPool() throws IOException {
      int count = u2();
      if (BytecodeParser.VERBOSE) {
        println("constant_pool_count: " + count);
      }
      constantPool = new CONSTANT_Info[count + 1];
      for (int i = 1; i < count; i++) {
        parseConstantPoolEntry(i);
        if (constantPool[i] instanceof CONSTANT_Long_Info
            || constantPool[i] instanceof CONSTANT_Double_Info)
          i++;
      }
    }

    private static final int CONSTANT_Class = 7;
    private static final int CONSTANT_FieldRef = 9;
    private static final int CONSTANT_MethodRef = 10;
    private static final int CONSTANT_InterfaceMethodRef = 11;
    private static final int CONSTANT_String = 8;
    private static final int CONSTANT_Integer = 3;
    private static final int CONSTANT_Float = 4;
    private static final int CONSTANT_Long = 5;
    private static final int CONSTANT_Double = 6;
    private static final int CONSTANT_NameAndType = 12;
    private static final int CONSTANT_Utf8 = 1;

    public void parseConstantPoolEntry(int i) throws IOException {
      int tag = u1();
      switch (tag) {
        case CONSTANT_Class:
          constantPool[i] = new CONSTANT_Class_Info(this);
          break;
        case CONSTANT_FieldRef:
          constantPool[i] = new CONSTANT_Fieldref_Info(this);
          break;
        case CONSTANT_MethodRef:
          constantPool[i] = new CONSTANT_Methodref_Info(this);
          break;
        case CONSTANT_InterfaceMethodRef:
          constantPool[i] = new CONSTANT_InterfaceMethodref_Info(this);
          break;
        case CONSTANT_String:
          constantPool[i] = new CONSTANT_String_Info(this);
          break;
        case CONSTANT_Integer:
          constantPool[i] = new CONSTANT_Integer_Info(this);
          break;
        case CONSTANT_Float:
          constantPool[i] = new CONSTANT_Float_Info(this);
          break;
        case CONSTANT_Long:
          constantPool[i] = new CONSTANT_Long_Info(this);
          break;
        case CONSTANT_Double:
          constantPool[i] = new CONSTANT_Double_Info(this);
          break;
        case CONSTANT_NameAndType:
          constantPool[i] = new CONSTANT_NameAndType_Info(this);
          break;
        case CONSTANT_Utf8:
          constantPool[i] = new CONSTANT_Utf8_Info(this);
          break;
        default:
          println("Unknown entry: " + tag);
      }
    }

  }

}
