/*
 * The JastAdd Extensible Java Compiler (http://jastadd.org) is covered
 * by the modified BSD License. You should have received a copy of the
 * modified BSD license with this compiler.
 *
 * Copyright (c) 2005-2008, Torbjorn Ekman
 * All rights reserved.
 */

import java.io.File;
import java.util.Set;
import java.util.HashSet;
import beaver.*;

aspect ClassPath {
  public interface BytecodeReader {
    CompilationUnit read(InputStream is, String fullName, Program p) throws FileNotFoundException, IOException;
  }
  public interface JavaParser {
    CompilationUnit parse(InputStream is, String fileName) throws IOException, beaver.Parser.Exception;
  }

  protected BytecodeReader Program.bytecodeReader;
  public void Program.initBytecodeReader(BytecodeReader r) {
    bytecodeReader = r;
  }

  protected JavaParser Program.javaParser;
  public void Program.initJavaParser(JavaParser p) {
    javaParser = p;
  }

  /**
   * @return The path to the source file, or the path to the file inside a Jar
   * file.
   */
  syn String CompilationUnit.relativeName() = getClassSource().relativeName();

  /**
   * @return The path to the source file, or the enclosing Jar file.
   */
  syn String CompilationUnit.pathName() = getClassSource().pathName();

  /**
   * @return {@code true} if this compilation unit was parsed from source.
   */
  syn boolean CompilationUnit.fromSource() = fromSource;

  inh CompilationUnit TypeDecl.compilationUnit();
  eq CompilationUnit.getChild().compilationUnit() = this;

  /**
   * Tracks all currently loaded classes in the program.
   */
  private Map<String,CompilationUnit> Program.classIndex =
    new HashMap<String,CompilationUnit>();

  /**
   * Tracks all currently available packages in the program classpath.
   */
  private Set<String> Program.packageIndex = new HashSet<String>();

  /**
   * Add a filename to the list of source files to process.
   * @param fileName file name of the source file
   * @return The CompilationUnit representing the source file,
   * or <code>null</code> if no such file exists
   */
  public CompilationUnit Program.addSourceFile(String fileName) {
    try {
      FilePath pathPart = new FilePath(fileName);
      packageIndex.addAll(pathPart.packages());
      CompilationUnit cu = pathPart.getCompilationUnit(this, fileName);
      if (cu != null) {
        addCompilationUnit(cu);
      }
      return cu;
    } catch (IOException e) {
      return null;
    }
  }

  /**
   * Iterate over all source files and on-demand loaded compilation units.
   */
  public Iterator<CompilationUnit> Program.compilationUnitIterator() {
    return new Iterator<CompilationUnit>() {
      int index = 0;
      public boolean hasNext() {
        return index < getNumCompilationUnit();
      }
      public CompilationUnit next() {
        if (getNumCompilationUnit() == index) {
          throw new java.util.NoSuchElementException();
        }
        return getCompilationUnit(index++);
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }

  /**
   * Get the input stream for a compilation unit specified using a canonical
   * name. This is used by the bytecode reader to load nested types
   */
  public InputStream Program.getInputStream(String name) {
    try {
      for (Iterator iter = classPath.iterator(); iter.hasNext(); ) {
        PathPart part = (PathPart) iter.next();
        ClassSource source = part.findSource(name);
        if (source != ClassSource.NONE) {
          return source.openInputStream();
        }
      }
    } catch(IOException e) {
    }
    throw new Error("Could not find nested type " + name);
  }

  /**
   * Load a compilation unit from disk using the following rules:
   * <ol>
   *   <li>Specified on the command line
   *   <li>Class file not older than source file
   *   <li>Source file
   * </ol>
   *
   * @param name Qualified name of class to load.
   * @return the loaded compilation unit
   */
  public CompilationUnit Program.getCompilationUnit(String name) {
    CompilationUnit available = classIndex.get(name);
    if (available != null) {
      return available;
    }
    try {
      ClassSource sourcePart = ClassSource.NONE;
      ClassSource classPart = ClassSource.NONE;
      for (PathPart part: sourcePath) {
        sourcePart = part.findSource(name);
        if (sourcePart != ClassSource.NONE) {
          break;
        }
      }
      for (PathPart part: classPath) {
        classPart = part.findSource(name);
        if (classPart != ClassSource.NONE) {
          break;
        }
      }

      if (sourcePart != ClassSource.NONE && (classPart == ClassSource.NONE ||
            classPart.getAge() < sourcePart.getAge())) {
        CompilationUnit unit = sourcePart.parseCompilationUnit(this);
        int index = name.lastIndexOf('.');
        if (index == -1) {
          return unit;
        }
        String pkgName = name.substring(0, index);
        if (pkgName.equals(unit.getPackageDecl())) {
          return unit;
        }
      }
      if (classPart != ClassSource.NONE) {
        CompilationUnit unit = classPart.parseCompilationUnit(this);
        int index = name.lastIndexOf('.');
        if (index == -1) {
          return unit;
        }
        String pkgName = name.substring(0, index);
        if (pkgName.equals(unit.getPackageDecl())) {
          return unit;
        }
      }
      return null;
    } catch(IOException e) {
    }
    return null;
  }

  /**
   * @return <code>true</code> if there is a package with the given name on
   * the classpath
   */
  public boolean Program.isPackage(String name) {
    return packageIndex.contains(name);
  }

  private ClassSource CompilationUnit.classSource = ClassSource.NONE;
  private boolean CompilationUnit.fromSource = false;

  public void CompilationUnit.setClassSource(ClassSource source) {
    this.classSource = source;
  }
  public ClassSource CompilationUnit.getClassSource() {
    return classSource;
  }
  public void CompilationUnit.setFromSource(boolean value) {
    this.fromSource = value;
  }

  private ArrayList<PathPart> Program.classPath = new ArrayList<PathPart>();
  private ArrayList<PathPart> Program.sourcePath = new ArrayList<PathPart>();

  /**
   * Set up the classpaths (standard + boot classpath).
   */
  public void Program.initPaths() {
    //System.err.println("Initializing class paths");

    ArrayList<String> classPaths = new ArrayList<String>();
    ArrayList<String> sourcePaths = new ArrayList<String>();

    String[] bootclasspaths;
    if (options().hasValueForOption("-bootclasspath")) {
      bootclasspaths = options().getValueForOption("-bootclasspath").split(File.pathSeparator);
    } else {
      bootclasspaths = System.getProperty("sun.boot.class.path").split(File.pathSeparator);
    }
    for(int i = 0; i < bootclasspaths.length; i++) {
      classPaths.add(bootclasspaths[i]);
      //System.err.println("Adding classpath " + bootclasspaths[i]);
    }

    String[] extdirs;
    if (options().hasValueForOption("-extdirs")) {
      extdirs = options().getValueForOption("-extdirs").split(File.pathSeparator);
    } else {
      extdirs = System.getProperty("java.ext.dirs").split(File.pathSeparator);
    }
    for (int i = 0; i < extdirs.length; i++) {
      classPaths.add(extdirs[i]);
      //System.err.println("Adding classpath " + extdirs[i]);
    }

    String[] userClasses = null;
    if (options().hasValueForOption("-classpath")) {
      userClasses = options().getValueForOption("-classpath").split(File.pathSeparator);
    } else if (options().hasValueForOption("-cp")) {
      userClasses = options().getValueForOption("-cp").split(File.pathSeparator);
    } else {
      userClasses = ".".split(File.pathSeparator);
    }
    if (!options().hasValueForOption("-sourcepath")) {
      for (int i = 0; i < userClasses.length; i++) {
        classPaths.add(userClasses[i]);
        sourcePaths.add(userClasses[i]);
        //System.err.println("Adding classpath/sourcepath " + userClasses[i]);
      }
    } else {
      for (int i = 0; i < userClasses.length; i++) {
        classPaths.add(userClasses[i]);
        //System.err.println("Adding classpath " + userClasses[i]);
      }
      userClasses = options().getValueForOption("-sourcepath").split(File.pathSeparator);
      for (int i = 0; i < userClasses.length; i++) {
        sourcePaths.add(userClasses[i]);
        //System.err.println("Adding sourcepath " + userClasses[i]);
      }
    }

    classPath = new ArrayList<PathPart>();
    sourcePath = new ArrayList<PathPart>();

    for (String path: classPaths) {
      PathPart part = PathPart.createClassPath(path);
      if (part != null) {
        addClassPath(part);
        //System.out.println("Adding classpath " + s);
      } else if (options().verbose()) {
        System.out.println("Warning: Could not use " + path + " as class path");
      }
    }
    for (String path: sourcePaths) {
      PathPart part = PathPart.createSourcePath(path);
      if (part != null) {
        addSourcePath(part);
        //System.out.println("Adding sourcepath " + path);
      } else if(options().verbose()) {
        System.out.println("Warning: Could not use " + path + " as source path");
      }
    }
  }

  /**
   * Add a path part to the library class path.
   */
  public void Program.addClassPath(PathPart pathPart) {
    classPath.add(pathPart);
    packageIndex.addAll(pathPart.packages());
  }

  /**
   * Add a path part to the user class path.
   */
  public void Program.addSourcePath(PathPart pathPart) {
    sourcePath.add(pathPart);
    packageIndex.addAll(pathPart.packages());
  }
}
