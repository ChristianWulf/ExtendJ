/*
 * The JastAdd Extensible Java Compiler (http://jastadd.org) is covered
 * by the modified BSD License. You should have received a copy of the
 * modified BSD license with this compiler.
 *
 * Copyright (c) 2005-2008, Torbjorn Ekman
 * All rights reserved.
 */

aspect GenericMethods {
  public void ParMethodAccess.typeCheck() {
    super.typeCheck();
    if(!decl().hostType().isUnknown()) {
      if(!(decl() instanceof ParMethodDecl))
        error("can not have type parameters on a non generic method");
      else {
        ParMethodDecl m = (ParMethodDecl)decl();
        if(!(m instanceof RawMethodDecl) && m.numTypeParameter() != getNumTypeArgument())
          error("generic method " + m.signature() + " requires " + m.numTypeParameter() + " type arguments");
        else {
        }
      }
    }
  }


  syn lazy final MethodDecl GenericMethodDecl.rawMethodDecl() = lookupParMethodDecl(new ArrayList());

  syn lazy GenericMethodDecl ParMethodDecl.genericMethodDecl() {
    return getGenericMethodDecl();
  }

  syn lazy GenericConstructorDecl ParConstructorDecl.genericConstructorDecl() {
    if(getParent() != null && getParent().getParent() instanceof GenericConstructorDecl)
      return (GenericConstructorDecl)getParent().getParent();
    return null;
  }

  syn nta MethodDecl GenericMethodDecl.lookupParMethodDecl(java.util.List typeArguments) {
    return newParMethodDecl(typeArguments);
  }

  public ParMethodDecl GenericMethodDecl.newParMethodDecl(java.util.List typeArguments) {
    ParMethodDecl methodDecl = typeArguments.isEmpty() ? new RawMethodDecl() : new ParMethodDecl();
    // adding a link to GenericMethodDecl to be used during substitution
    // instead of the not yet existing parent link
    methodDecl.setGenericMethodDecl(this);
    List list = new List();
    if(typeArguments.isEmpty()) {
      GenericMethodDecl original = original();
      for(int i = 0; i < original.getNumTypeParameter(); i++)
        list.add(original.getTypeParameter(i).erasure().createBoundAccess());
    }
    else {
      for(Iterator iter = typeArguments.iterator(); iter.hasNext(); )
        list.add(((TypeDecl)iter.next()).createBoundAccess());
    }
    methodDecl.setTypeArgumentList(list);
    methodDecl.setModifiers((Modifiers)getModifiers().fullCopy());
    methodDecl.setTypeAccess(getTypeAccess().type().substituteReturnType(methodDecl));
    methodDecl.setID(getID());
    methodDecl.setParameterList(getParameterList().substitute(methodDecl));
    methodDecl.setExceptionList(getExceptionList().substitute(methodDecl));
    return methodDecl;
  }


}

aspect TypeCheck {
  // Disable error checking in instantiated generic methods
  public void ParMethodDecl.collectErrors() {
  }
  // Allow covariant return types
  refine TypeHierarchyCheck eq MethodDecl.mayOverrideReturn(MethodDecl m) {
    return type().instanceOf(m.type());
  }
}

aspect GenericMethodsNameAnalysis {

  eq ParMethodAccess.getTypeArgument().nameType() = NameType.TYPE_NAME;
  eq ParMethodAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq GenericMethodDecl.getTypeParameter().nameType() = NameType.TYPE_NAME;

  inh SimpleSet GenericMethodDecl.lookupType(String name);
  syn SimpleSet GenericMethodDecl.localLookupType(String name) {
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(original().getTypeParameter(i).name().equals(name))
        return SimpleSet.emptySet.add(original().getTypeParameter(i));
    }
    return SimpleSet.emptySet;
  }
  eq GenericMethodDecl.getChild().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);

  eq ParConstructorAccess.getTypeArgument().nameType() = NameType.TYPE_NAME;
  eq ParConstructorAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq ParSuperConstructorAccess.getTypeArgument().nameType() = NameType.TYPE_NAME;
  eq ParSuperConstructorAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq GenericConstructorDecl.getTypeParameter().nameType() = NameType.TYPE_NAME;

  inh SimpleSet GenericConstructorDecl.lookupType(String name);
  syn SimpleSet GenericConstructorDecl.localLookupType(String name) {
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(original().getTypeParameter(i).name().equals(name))
        return SimpleSet.emptySet.add(original().getTypeParameter(i));
    }
    return SimpleSet.emptySet;
  }
  eq GenericConstructorDecl.getChild().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);

  eq ParClassInstanceExpr.getTypeArgument().nameType() = NameType.TYPE_NAME;
  eq ParClassInstanceExpr.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);

}

aspect GenericMethodsPrettyPrint {

  public void ParMethodAccess.prettyPrint(StringBuffer sb) {
    sb.append("<");
    for(int i = 0; i < getNumTypeArgument(); i++) {
      if(i != 0) sb.append(", ");
      getTypeArgument(i).prettyPrint(sb);
    }
    sb.append(">");
    super.prettyPrint(sb);
  }

  public void ParConstructorAccess.prettyPrint(StringBuffer sb) {
    sb.append("<");
    for(int i = 0; i < getNumTypeArgument(); i++) {
      if(i != 0) sb.append(", ");
      getTypeArgument(i).prettyPrint(sb);
    }
    sb.append(">");
    super.prettyPrint(sb);
  }

  public void ParSuperConstructorAccess.prettyPrint(StringBuffer sb) {
    sb.append("<");
    for(int i = 0; i < getNumTypeArgument(); i++) {
      if(i != 0) sb.append(", ");
      getTypeArgument(i).prettyPrint(sb);
    }
    sb.append(">");
    super.prettyPrint(sb);
  }

  public void ParClassInstanceExpr.prettyPrint(StringBuffer sb) {
    sb.append("<");
    for(int i = 0; i < getNumTypeArgument(); i++) {
      if(i != 0) sb.append(", ");
      getTypeArgument(i).prettyPrint(sb);
    }
    sb.append(">");
    super.prettyPrint(sb);
  }

  private void GenericMethodDecl.ppTypeParameters(StringBuffer sb) {
    sb.append(" <");
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(i != 0) sb.append(", ");
      original().getTypeParameter(i).prettyPrint(sb);
    }
    sb.append("> ");
  }

  public void GenericMethodDecl.prettyPrint(StringBuffer sb) {
    sb.append(indent());
    getModifiers().prettyPrint(sb);

    ppTypeParameters(sb);

    getTypeAccess().prettyPrint(sb);
    sb.append(" " + getID());
    sb.append("(");
    if(getNumParameter() > 0) {
      getParameter(0).prettyPrint(sb);
      for(int i = 1; i < getNumParameter(); i++) {
        sb.append(", ");
        getParameter(i).prettyPrint(sb);
      }
    }
    sb.append(")");
    if(getNumException() > 0) {
      sb.append(" throws ");
      getException(0).prettyPrint(sb);
      for(int i = 1; i < getNumException(); i++) {
        sb.append(", ");
        getException(i).prettyPrint(sb);
      }
    }
    if(hasBlock()) {
      sb.append(" ");
      getBlock().prettyPrint(sb);
    }
    else {
      sb.append(";\n");
    }
  }

  public void GenericConstructorDecl.prettyPrint(StringBuffer sb) {
    sb.append(indent());
    getModifiers().prettyPrint(sb);

    sb.append(" <");
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(i != 0) sb.append(", ");
      original().getTypeParameter(i).prettyPrint(sb);
    }
    sb.append("> ");

    sb.append(getID() + "(");
    if(getNumParameter() > 0) {
      getParameter(0).prettyPrint(sb);
      for(int i = 1; i < getNumParameter(); i++) {
        sb.append(", ");
        getParameter(i).prettyPrint(sb);
      }
    }
    sb.append(")");
    if(getNumException() > 0) {
      sb.append(" throws ");
      getException(0).prettyPrint(sb);
      for(int i = 1; i < getNumException(); i++) {
        sb.append(", ");
        getException(i).prettyPrint(sb);
      }
    }

    sb.append(" {");
    if(hasConstructorInvocation()) {
      sb.append(indent());
      getConstructorInvocation().prettyPrint(sb);
    }
    for(int i = 0; i < getBlock().getNumStmt(); i++) {
      sb.append(indent());
      getBlock().getStmt(i).prettyPrint(sb);
    }
    sb.append(indent());
    sb.append("}");
  }

}
