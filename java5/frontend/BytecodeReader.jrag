/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2015, Jesper Ã–qvist <joqvist@google.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.BufferedInputStream;
import java.io.DataInputStream;

aspect BytecodeReader {

  public class BytecodeParser extends AbstractClassfileParser implements Flags {

    public String outerClassName;

    public BytecodeParser(InputStream in, String name) {
      super(in, name);
    }

    @Override
    public boolean outerClassNameEquals(String name) {
      return outerClassName != null && outerClassName.equals(name);
    }

    public CompilationUnit parse(TypeDecl outerTypeDecl, String outerClassName,
        Program classPath, boolean isInner)
        throws FileNotFoundException, IOException {
      isInnerClass = isInner;
      return parse(outerTypeDecl, outerClassName, classPath);
    }

    public CompilationUnit parse(TypeDecl outerTypeDecl, String outerClassName, Program program)
        throws FileNotFoundException, IOException {

      if (VERBOSE) {
        println("Parsing byte codes in " + name);
      }

      this.outerClassName = outerClassName;
      parseMagic();
      int minor = parseMinor();
      int major = parseMajor();
      if (AbstractClassfileParser.VERBOSE) {
        println(String.format("Classfile version: %d.%d", major, minor));
      }
      if (major > 51) {
        // The Java 5 bytecode parser handles up to Java 7 bytecode fine.
        error(String.format("Can not parse classfile version %d.%d."
              + " Classfile versions up to 51.x (Java 7) are supported by"
              + " this version of the compiler.",
              major, minor));
      }
      parseConstantPool();
      CompilationUnit cu = new CompilationUnit();
      TypeDecl typeDecl = parseTypeDecl();
      cu.setPackageDecl(classInfo.packageDecl());
      cu.addTypeDecl(typeDecl);
      parseFields(typeDecl);
      parseMethods(typeDecl);

      // Parse attributes, and if we have an inner class, then execute the branch.
      if (new Attributes.TypeAttributes(this, typeDecl, outerTypeDecl, program).isInnerClass()) {
        // This is a workaround for the fact that JastAdd stores inner classes as members of
        // their outer classes, even for inner classes that come from bytecode;
        // to avoid having inner classes show up as top-level classes, we remove them here
        // from the compilation unit again...

        // First add the cu to the program, so that getTypeDecls() won't fail.
        program.addCompilationUnit(cu);
        // Then clear the compilation unit.
        for (int i=0;i<cu.getTypeDecls().getNumChild();i++) {
          cu.getTypeDecls().removeChild(i);
        }
        // Remove the compilation unit from the program again.
        program.getCompilationUnits().removeChild(program.getCompilationUnits().getIndexOfChild(cu));
      }

      return cu;
    }

    public TypeDecl parseTypeDecl() throws IOException {
      int flags = u2();
      Modifiers modifiers = modifiers(flags & 0xfddf);
      if ((flags & (ACC_INTERFACE | ACC_ENUM)) == ACC_ENUM) {
        // Modifiers <ID:String> /[SuperClass:Access]/ Implements:Access* BodyDecl*;
        EnumDecl decl = new EnumDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        // TODO attempting to set NTA child?
        decl.setImplementsList(parseInterfaces(new List()));
        return decl;
      } else if ((flags & ACC_INTERFACE) == 0) {
        ClassDecl decl = new ClassDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        decl.setSuperClassOpt(
            superClass == null
            ? new Opt()
            : new Opt(superClass));
        decl.setImplementsList(parseInterfaces(new List()));
        return decl;
      } else if ((flags & ACC_ANNOTATION) == 0) {
        InterfaceDecl decl = new InterfaceDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        decl.setSuperInterfaceList(parseInterfaces(
            superClass == null
            ? new List()
            : new List().add(superClass)));
        return decl;
      } else {
        AnnotationDecl decl = new AnnotationDecl();
        decl.setModifiers(modifiers);
        decl.setID(parseThisClass());
        Access superClass = parseSuperClass();
        parseInterfaces(
            superClass == null
            ? new List()
            : new List().add(superClass));
        return decl;
      }
    }

    public static Access fromClassName(String s) {
      // Sample ClassName: a/b/c$d$e
      // the package name ends at the last '/'
      // after that follows a list of type names separated by '$'
      // all except the first are nested types

      String packageName = "";
      int index = s.lastIndexOf('/');
      if (index != -1) {
        packageName = s.substring(0, index).replace('/', '.');
      }
      String typeName = s.substring(index + 1, s.length());
      if (typeName.indexOf('$') != -1) {
        return new BytecodeTypeAccess(packageName, typeName);
      } else {
        return new TypeAccess(packageName, typeName);
      }
    }

    public void parseMethods(TypeDecl typeDecl) throws IOException {
      int count = u2();
      if (VERBOSE) {
        println("Methods (" + count + "):");
      }
      for (int i = 0; i < count; i++) {
        if (VERBOSE) {
          print("  Method nbr " + i + " ");
        }
        MethodInfo info = new MethodInfo(this);
        if (!info.isSynthetic() && !info.name.equals("<clinit>")) {
          typeDecl.addBodyDecl(info.bodyDecl());
        }
      }
    }

    @Override
    public void parseConstantPoolEntry(int i) throws IOException {
      int tag = u1();
      switch (tag) {
        case CONSTANT_Class:
          constantPool[i] = new CONSTANT_Class_Info(this);
          break;
        case CONSTANT_FieldRef:
          constantPool[i] = new CONSTANT_Fieldref_Info(this);
          break;
        case CONSTANT_MethodRef:
          constantPool[i] = new CONSTANT_Methodref_Info(this);
          break;
        case CONSTANT_InterfaceMethodRef:
          constantPool[i] = new CONSTANT_InterfaceMethodref_Info(this);
          break;
        case CONSTANT_String:
          constantPool[i] = new CONSTANT_String_Info(this);
          break;
        case CONSTANT_Integer:
          constantPool[i] = new CONSTANT_Integer_Info(this);
          break;
        case CONSTANT_Float:
          constantPool[i] = new CONSTANT_Float_Info(this);
          break;
        case CONSTANT_Long:
          constantPool[i] = new CONSTANT_Long_Info(this);
          break;
        case CONSTANT_Double:
          constantPool[i] = new CONSTANT_Double_Info(this);
          break;
        case CONSTANT_NameAndType:
          constantPool[i] = new CONSTANT_NameAndType_Info(this);
          break;
        case CONSTANT_Utf8:
          constantPool[i] = new CONSTANT_Utf8_Info(this);
          break;
        default:
          println("Unknown entry: " + tag);
      }
    }

  }

  public class Signatures {
    // simple parser framework
    String data;
    int pos;
    public Signatures(String s) {
      data = s;
      pos = 0;
    }

    public boolean next(String s) {
      for (int i = 0; i < s.length(); i++) {
        if (data.charAt(pos + i) != s.charAt(i)) {
          return false;
        }
      }
      return true;
    }

    public void eat(String s) {
      for (int i = 0; i < s.length(); i++) {
        if (data.charAt(pos + i) != s.charAt(i)) {
          error(s);
        }
      }
      pos += s.length();
    }

    public void error(String s) {
      throw new Error("Expected " + s + " but found " + data.substring(pos));
    }

    public String identifier() {
      int i = pos;
      while (Character.isJavaIdentifierPart(data.charAt(i))) {
        i++;
      }
      String result = data.substring(pos, i);
      pos = i;
      return result;
    }

    public boolean eof() {
      return pos == data.length();
    }

    // 4.4.4 Signatures

    public static class ClassSignature extends Signatures {
      public ClassSignature(String s) {
        super(s);
        classSignature();
      }
      void classSignature() {
        if (next("<")) {
          formalTypeParameters();
        }
        superclassSignature = parseSuperclassSignature();
        while (!eof()) {
          superinterfaceSignature.add(parseSuperinterfaceSignature());
        }
      }

      public boolean hasFormalTypeParameters() { return typeParameters != null; }
      public List typeParameters() { return typeParameters; }

      public boolean hasSuperclassSignature() { return superclassSignature != null; }
      public Access superclassSignature() { return superclassSignature; }
      protected Access superclassSignature;

      public boolean hasSuperinterfaceSignature() { return superinterfaceSignature.getNumChildNoTransform() != 0; }
      public List superinterfaceSignature() { return superinterfaceSignature; }
      protected List superinterfaceSignature = new List();

      Access parseSuperclassSignature() {
        return classTypeSignature();
      }

      Access parseSuperinterfaceSignature() {
        return classTypeSignature();
      }
    }

    public static class FieldSignature extends Signatures {
      public FieldSignature(String s) {
        super(s);
        fieldTypeAccess = fieldTypeSignature();
      }
      Access fieldTypeAccess() {
        return fieldTypeAccess;
      }
      private Access fieldTypeAccess;
    }

    public static class MethodSignature extends Signatures {
      public MethodSignature(String s) {
        super(s);
        methodTypeSignature();
      }
      void methodTypeSignature() {
        if (next("<")) {
          formalTypeParameters();
        }
        eat("(");
        while (!next(")")) {
          parameterTypes.add(typeSignature());
        }
        eat(")");
        returnType = parseReturnType();
        while (!eof()) {
          exceptionList.add(throwsSignature());
        }
      }
      Access parseReturnType() {
        if (next("V")) {
          eat("V");
          return new PrimitiveTypeAccess("void");
        } else {
          return typeSignature();
        }
      }

      Access throwsSignature() {
        eat("^");
        if (next("L")) {
          return classTypeSignature();
        } else {
          return typeVariableSignature();
        }
      }

      public boolean hasFormalTypeParameters() { return typeParameters != null; }
      public List typeParameters() { return typeParameters; }

      public Collection parameterTypes() { return parameterTypes; }
      protected Collection parameterTypes = new ArrayList();

      public List exceptionList() { return exceptionList; }
      public boolean hasExceptionList() { return exceptionList.getNumChildNoTransform() != 0; }
      protected List exceptionList = new List();

      protected Access returnType = null;
      public boolean hasReturnType() { return returnType != null; }
      public Access returnType() { return returnType; }
    }

    protected List typeParameters;

    void formalTypeParameters() {
      eat("<");
      typeParameters = new List();
      do {
        typeParameters.add(formalTypeParameter());
      } while (!next(">"));
      eat(">");
    }

    TypeVariable formalTypeParameter() {
      String id = identifier();
      List bounds = new List();
      Access classBound = classBound();
      if (classBound != null) {
        bounds.add(classBound);
      }
      while (next(":")) {
        bounds.add(interfaceBound());
      }
      if (bounds.getNumChildNoTransform() == 0) {
        bounds.add(new TypeAccess("java.lang", "Object"));
      }
      return new TypeVariable(new Modifiers(new List()), id, new List(), bounds);
    }

    Access classBound() {
      eat(":");
      if (nextIsFieldTypeSignature()) {
        return fieldTypeSignature();
      } else {
        return null;
        //return new TypeAccess("java.lang", "Object");
      }
    }

    Access interfaceBound() {
      eat(":");
      return fieldTypeSignature();
    }


    Access fieldTypeSignature() {
      if (next("L")) {
        return classTypeSignature();
      } else if (next("[")) {
        return arrayTypeSignature();
      } else if (next("T")) {
        return typeVariableSignature();
      } else {
        error("L or [ or T");
      }
      return null; // error never returns
    }
    boolean nextIsFieldTypeSignature() {
      return next("L") || next("[") || next("T");
    }

    Access classTypeSignature() {
      eat("L");
      // Package and Type Name
      StringBuilder packageName = new StringBuilder();
      String typeName = identifier();
      while (next("/")) {
        eat("/");
        if (packageName.length() != 0) {
          packageName.append(".");
        }
        packageName.append(typeName);
        typeName = identifier();
      }
      Access a = typeName.indexOf('$') == -1 ?
        new TypeAccess(packageName.toString(), typeName) :
        new BytecodeTypeAccess(packageName.toString(), typeName);
      if (next("<")) { // type arguments of top level type
        a = new ParTypeAccess(a, typeArguments());
      }
      while (next(".")) { // inner classes
        a = a.qualifiesAccess(classTypeSignatureSuffix());
      }
      eat(";");
      return a;
    }

    Access classTypeSignatureSuffix() {
      eat(".");
      String id = identifier();
      Access a = id.indexOf('$') == -1 ?
        new TypeAccess(id) : new BytecodeTypeAccess("", id);
      if (next("<")) {
        a = new ParTypeAccess(a, typeArguments());
      }
      return a;
    }

    Access typeVariableSignature() {
      eat("T");
      String id = identifier();
      eat(";");
      return new TypeAccess(id);
    }

    List typeArguments() {
      eat("<");
      List list = new List();
      do {
        list.add(typeArgument());
      } while (!next(">"));
      eat(">");
      return list;
    }

    Access typeArgument() {
      if (next("*")) {
        eat("*");
        return new Wildcard();
      } else if (next("+")) {
        eat("+");
        return new WildcardExtends(fieldTypeSignature());
      } else if (next("-")) {
        eat("-");
        return new WildcardSuper(fieldTypeSignature());
      } else {
        return fieldTypeSignature();
      }
    }

    Access arrayTypeSignature() {
      eat("[");
      return new ArrayTypeAccess(typeSignature());
    }

    Access typeSignature() {
      if (nextIsFieldTypeSignature()) {
        return fieldTypeSignature();
      } else {
        return baseType();
      }
    }

    Access baseType() {
      if (next("B")) {
        eat("B"); return new PrimitiveTypeAccess("byte");
      } else if (next("C")) {
        eat("C"); return new PrimitiveTypeAccess("char");
      } else if (next("D")) {
        eat("D"); return new PrimitiveTypeAccess("double");
      } else if (next("F")) {
        eat("F"); return new PrimitiveTypeAccess("float");
      } else if (next("I")) {
        eat("I"); return new PrimitiveTypeAccess("int");
      } else if (next("J")) {
        eat("J"); return new PrimitiveTypeAccess("long");
      } else if (next("S")) {
        eat("S"); return new PrimitiveTypeAccess("short");
      } else if (next("Z")) {
        eat("Z"); return new PrimitiveTypeAccess("boolean");
      }
      error("baseType");
      return null; // error never returns
    }
  }

  public interface Flags {
    public int ACC_PUBLIC = 0x0001;
    public int ACC_PRIVATE = 0x0002;
    public int ACC_PROTECTED = 0x0004;
    public int ACC_STATIC = 0x0008;
    public int ACC_FINAL = 0x0010;
    public int ACC_SUPER = 0x0020;
    public int ACC_SYNCHRONIZED = 0x0020;
    public int ACC_VOLATILE = 0x0040;
    public int ACC_BRIDGE = 0x0040;
    public int ACC_TRANSIENT = 0x0080;
    public int ACC_VARARGS = 0x0080;
    public int ACC_NATIVE = 0x0100;
    public int ACC_INTERFACE = 0x0200;
    public int ACC_ABSTRACT = 0x0400;
    public int ACC_STRICT = 0x0800;
    public int ACC_SYNTHETIC = 0x1000;
    public int ACC_ANNOTATION = 0x2000;
    public int ACC_ENUM = 0x4000;
  }
}
